{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This lib is used to manage ch395 chip for 6502 cpu</p>"},{"location":"assembly/","title":"Assembly","text":""},{"location":"assembly/#assembly","title":"Assembly","text":""},{"location":"assembly/#ch395_check_exist","title":"ch395_check_exist","text":"<p>Description</p> <p>This command is used to test the communication interface and working state to check whether CH395 is working properly. This command needs to input 1 byte of data, which can be any data. If CH395 is working properly, the output data of CH395 will be the bitwise reverse of the input data. For example, if the input data is 57H, the output data will be A8H.</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Returns '#CH395_DETECTED' if it exists</li> </ul> <p>Example</p> <pre><code> jsr ch395_check_exist\n cmp #CH395_DETECTED\n beq ch395_connected\n rts\nch395_connected:\n</code></pre>"},{"location":"assembly/#ch395_clear_recv_buf_sn","title":"ch395_clear_recv_buf_sn","text":"<p>Description</p> <p>This command is used to clear the Socket receive buffer. It is necessary to input 1 byte of Socket index value. Upon receiving this command, CH395 will reset the receiving length of this Socket, and the receiving pointer will point to the buffer head.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Socket ID\n jsr ch395_clear_recv_buf_sn\n</code></pre>"},{"location":"assembly/#ch395_close_socket_sn","title":"ch395_close_socket_sn","text":"<p>Description</p> <p>This command is used to close Socket. It is necessary to input a 1 byte of Socket index value. After Socket is closed, the receive buffer and transmit buffer of Socket are emptied, but the configuration information is still reserved, and you just need to open the Socket again when using the Socket the next time. In TCP mode, CH395 will automatically disconnect TCP before turning off Socket.</p> <p>Input</p> <ul> <li>Accumulator : The id of the socket to close</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket ID\n jsr ch395_close_socket_sn\n</code></pre>"},{"location":"assembly/#ch395_dhcp_enable","title":"ch395_dhcp_enable","text":"<p>Description</p> <p>This command is used to start or stop DHCP. It is necessary to input a 1-byte flag. If the flag is 1, it will indicate that DHCP is on; if the flag is 0, it will indicate that DHCP is off. CH395 must be initialized before DHCP is started. After DHCP is started, CH395 will broadcast DHCPDISCOVER message to the network to discover DHCP Server, request the address and other configuration parameters after finding DHCP Server, and then generate GINT_STAT_DHCP interrupt. MCU can send GET_DHCP_STATUS command to get DHCP status. If the status code is 0, it will indicate success, and MCU can send the command GET_IP_INF to get IP, MASK and other information. If the status code is 1, it will indicate error, which is generally caused by timeout, for example, no DHCP Server is found. DHCP is always in a working state after startup unless it receives a DHCP shutdown command from MCU. During this process, if DHCP Server reassigns a configuration to CH395 and the configuration is different from the original configuration, CH395 will still generate an interrupt. After timeout interrupt is generated, if DHCP Server is not found, CH395 will continue to send DHCPDISCOVER message at an interval of about 16 seconds. It takes about 20MS to execute this command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status</p> <p>Input</p> <ul> <li>Accumulator : The mode to activate DHCP mode</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"assembly/#ch395_enter_sleep","title":"ch395_enter_sleep","text":"<p>Description</p> <p>This command enables CH395 chip in a low-power sleep suspended state. When MCU writes a new command to CH395 (no data input command, such as CMD_GET_IC_VER), it will exit the low-power state. For the parallel port and SPI interface communication modes, active SCS chip selection will also cause CH395 to exit the low-power state, so MCU shall immediately disable the SCS chip selection after sending the command CMD_ENTER_SLEEP. In sleep state, MAC and PHY of CH395 will be in power off mode and disconnect Ethernet. Typically, it takes several milliseconds for CH395 to exit the low-power state.</p> <p>Does not work</p>"},{"location":"assembly/#ch395_get_cmd_status","title":"ch395_get_cmd_status","text":"<p>Description</p> <p>This command is used to get the command execution status. CH395 will output 1 byte of data, which is the command execution state. The command execution status is as follows:</p> <p>Example</p> <pre><code> jsr ch395_get_cmd_status\n ; Check A for STATUS\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"assembly/#ch395_get_dhcp_status","title":"ch395_get_dhcp_status","text":"<p>Description</p> <p>Get dhcp status</p> <p>Example</p> <pre><code> jsr ch395_get_dhcp_status\n ; Check A for dhcp status\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"assembly/#ch395_get_glob_int_status_all","title":"ch395_get_glob_int_status_all","text":"<p>Description</p> <p>This command is used to get the global interrupt status. CH395 will output 2 bytes of global interrupt status after receiving this command. Global interrupt status is defined as follows:</p> <p>Returns</p> <ul> <li>Accumulator : int status state CH395_GINT_STAT_SOCK0 CH395_GINT_STAT_SOCK1 CH395_GINT_STAT_SOCK2 CH395_GINT_STAT_SOCK3 CH395_GINT_STAT_DHCP CH395_GINT_STAT_PHY_CHANGE CH395_GINT_STAT_IP_CONFLI CH395_GINT_STAT_UNREACH</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li> <p>X Register : int status state CH395_GINT_STAT_SOCK4 CH395_GINT_STAT_SOCK5 CH395_GINT_STAT_SOCK6 CH395_GINT_STAT_SOCK7</p> </li> <li> <p>X Register </p> </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status_all\n ; check accumulator to get interrupts states\n ; check X to get interrupts states\n</code></pre> <p>Does not work</p>"},{"location":"assembly/#ch395_get_glob_int_status","title":"ch395_get_glob_int_status","text":"<p>Description</p> <p>This command is used to get the global interrupt status. CH395 will output 1 byte of global interrupt status after receiving this command. Global interrupt status is defined as follows:</p> <p>Returns</p> <ul> <li>Accumulator : int status state CH395_GINT_STAT_SOCK0 CH395_GINT_STAT_SOCK1 CH395_GINT_STAT_SOCK2 CH395_GINT_STAT_SOCK3 CH395_GINT_STAT_DHCP CH395_GINT_STAT_PHY_CHANGE CH395_GINT_STAT_IP_CONFLI CH395_GINT_STAT_UNREACH</li> </ul> <p>Modify</p> <ul> <li>Accumulator  Bit Name Description</li> </ul> <p>7 GINT_STAT_SOCK3 Socket3 interrupt</p> <p>6 GINT_STAT_SOCK2 Socket2 interrupt</p> <p>5 GINT_STAT_SOCK1 Socket1 interrupt</p> <p>4 GINT_STAT_SOCK0 Socket0 interrupt</p> <p>3 GINT_STAT_DHCP DHCP interrupt</p> <p>2 GINT_STAT_PHY_CHANGE PHY status change interrupt</p> <p>1 GINT_STAT_IP_CONFLI IP conflict</p> <p>0 GINT_STAT_UNREACH Inaccessible interrupt</p> <p>\u2460 GINT_STAT_UNREACH: Inaccessible interrupt. When CH395 receives ICMP inaccessible interrupt</p> <p>message, it saves the IP address, port and protocol type of the inaccessible IP packet in the inaccessible</p> <p>information table, and then generates an interrupt. When the MCU receives the interrupt, it can send the</p> <p>command GET_UNREACH_IPPORT to get the inaccessible information.</p> <p>\u2461 GINT_STAT_IP_CONFLI: IP conflict interrupt. This interrupt is generated when CH395 detects that its</p> <p>IP address is the same as that of other network devices in the same network segment.</p> <p>\u2462 GINT_STAT_PHY_CHANGE: PHY change interrupt. This interrupt is generated when PHY connection</p> <p>of CH395 changes, for example, PHY state changes from the connected state to the disconnected state or</p> <p>from the disconnected state to the connected state. MCU can send GET_PHY_STATUS command to get</p> <p>the current PHY connection status.</p> <p>\u2463 GINT_STAT_DHCP: DHCP interrupt. If MCU enables DHCP function of CH395, CH395 will generate</p> <p>this interrupt. MCU can send the command CMD_GET_DHCP_STATUS to get the DHCP status. If the</p> <p>status is 0, it will indicate success; otherwise, it will indicate timeout failure.</p> <p>\u2464 GINT_STAT_SOCK0 - GINT_STAT_SOCK3: Socket interrupt. When there is an interrupt event in</p> <p>Socket, CH395 will generate this interrupt. MCU needs to send GET_INT_STATUS_SN to get the</p> <p>interrupt status of Socket. Please refer to GET_INT_STATUS_SN.</p> <p>When this command is completed, CH395 will set INT# pin to high level and clear the global interrupt</p> <p>status</p> <ul> <li>Accumulator </li> <li>Accumulator : Status </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status\n ; check accumulator to get interrupts states\n</code></pre>"},{"location":"assembly/#ch395_get_ic_ver","title":"ch395_get_ic_ver","text":"<p>Description</p> <p>This command is used to get the chip and firmware versions. 1 byte of data returned is the version number, the bit 7 is 0, the bit 6 is 1, and the bits 5-0 are the version number. If the returned value is 41H, remove bits 7 and 6, and the version number will be 01H. It is called chip version in this text</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Version </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_ic_ver\n ; Check A for version\n rts\n</code></pre>"},{"location":"assembly/#ch395_get_int_status_sn","title":"ch395_get_int_status_sn","text":"<p>Description</p> <p>This command is used to get the interrupt status of Socket. It is necessary to input 1 byte of Socket index value. After receiving this command, CH395 will output 1 byte of Socket interrupt code. The interrupt code bits are defined as follows:</p> <p>A7 - Reserved</p> <p>6 SINT_STAT_TIM_OUT Timeout</p> <p>5 - Reserved</p> <p>4 SINT_STAT_DISCONNECT TCP disconnected</p> <p>3 SINT_STAT_CONNECT TCP connected</p> <p>2 SINT_STAT_RECV Receive buffer not empty</p> <p>1 SINT_STAT_SEND_OK Send Success</p> <p>0 SINT_STAT_SENBUF_FREE Transmit buffer free</p> <p>\u2460 SINT_STAT_SENBUF_FREE, transmit buffer free interrupt. After MCU writes data to the transmit</p> <p>buffer of Socket, CH395 will quickly copy the data to the internal protocol stack or MAC buffer, in order</p> <p>to encapsulate the data. When the data copying is finished, this interrupt will be generated. MCU can</p> <p>continue to write the subsequent data to the transmit buffer. After MCU writes data to the transmit buffer</p> <p>of Socket once, it must write the next data until the interruption is generated.</p> <p>\u2461 SINT_STAT_SEND_OK, send OK interrupt. This interrupt indicates that the data packet is sent</p> <p>successfully. This interrupt will be generated after Sokcet sends a packet of data successfully. After MCU</p> <p>writes data to Socket buffer once, CH395 may encapsulate the data into several data packets for sending,</p> <p>so several send OK interrupts may be generated.</p> <p>\u2462 SINT_STAT_CONNECT, TCP linkage interrupt, active only in TCP mode. It indicates that TCP</p> <p>connection is successful, and MCU can transmit data only after the interrupt is generated.</p> <p>\u2463 SINT_STAT_DISCONNECT, TCP disconnection interrupt, only active in TCP mode, indicating TCP</p> <p>disconnection.</p> <p>\u2464 SINT_STAT_TIM_OUT. This interrupt will be generated in TCP mode when a timeout occurs during a</p> <p>TCP connection, disconnection, data sending and other processes. This interrupt will be generated if the</p> <p>data is not sent successfully in IPRAW or UDP mode.</p> <p>After the interrupts SINT_STAT_DISCONNECT and SINT_STAT_TIM_OUT are generated, CH395 takes</p> <p>different actions depending on whether the FUN_PARA_FLAG_SOCKET_CLOSE bit is 1 or 0. If</p> <p>FUN_PARA_FLAG_SOCKET_CLOSE is 0, CH395 will actively set the Socket state to the OFF state and</p> <p>clear all relevant buffers after the above two interrupts are generated. Otherwise, it will not do any operation</p> <p>command to close the Socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Status of selected socket</li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Check socket 1\n jsr ch395_get_int_status_sn\n ; Check interrupt type\n and #CH395_SINT_STAT_SEND_OK\n cmp #CH395_SINT_STAT_SEND_OK\n beq @send_ok\n rts\n</code></pre>"},{"location":"assembly/#ch395_get_ip_inf","title":"ch395_get_ip_inf","text":"<p>Description</p> <p>Get ip info</p> <p>Input</p> <ul> <li>Accumulator : the ptr to modify (Ptr must be 20 bytes length)</li> <li>X Register : the ptr to modify (Ptr must be 20 bytes length)</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RESTmp value</li> </ul> <p>Example</p> <pre><code> lda #&lt;ip_address\n ldx #&gt;ip_address\n ldx #$00\n jsr ch395_get_ip_inf\n rts\nip_address:\n .res 4\n</code></pre>"},{"location":"assembly/#ch395_get_mac_adress","title":"ch395_get_mac_adress","text":"<p>Description</p> <p>Get mac address</p> <p>Input</p> <ul> <li>Accumulator : the ptr</li> <li>X Register : the ptr</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RESTmp value</li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : the content of ptr modified</p> </li> <li> <p>X Register : the content of ptr modified</p> </li> </ul> <p>Example</p> <pre><code> lda #&lt;mac_address\n ldx #&gt;mac_address\n ldx #$00\n jsr ch395_get_mac_adress\n rts\nmac_address:\n .res 10\n</code></pre>"},{"location":"assembly/#ch395_get_phy_status","title":"ch395_get_phy_status","text":"<p>Description</p> <p>This command is used to get PHY connection status. After receiving this command, CH395 will query the current PHY connection status and output 1-byte PHY connection status code: PHY is disconnected when the connection status code is 01H; PHY connection is 10M full duplex when the connection status code is 02H; PHY connection is 10M half duplex when the connection status code is 04H. PHY connection is 100M full duplex when the connection status code is 08H; PHY connection is 100M half duplex when the connection status code is 10H</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : The physical status</li> </ul> <p>Example</p> <pre><code> jsr ch395_get_phy_status\n ; Check A physical status\n rts\n</code></pre>"},{"location":"assembly/#ch395_get_recv_len_sn","title":"ch395_get_recv_len_sn","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_recv_len_sn\n ; check A and X for length received\nch395_connected:\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The length</p> </li> <li> <p>X Register : The length</p> </li> </ul>"},{"location":"assembly/#ch395_get_remot_ipp_sn","title":"ch395_get_remot_ipp_sn","text":"<p>Description</p> <p>This command is used to get the remote IP address and port number. It is necessary to input 1 byte of Socket index value. CH395 will output 4 bytes of IP address and 2 bytes of port number (low bytes in front). After Socket works in TCP Server mode and the connection is established, MCU can get the remote IP address and port number through this command</p> <p>Input</p> <ul> <li>Accumulator : The Socket for the ip to get</li> <li>X Register : The ptr (high) to store the ip</li> <li>Y Register : The ptr (low) to store the ip</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RES</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n ldx #&lt;ip_dest\n ldy #&gt;ip_dest\n jsr ch395_get_remot_ipp_sn\n rts\nipdest:\n .byte 192,168,0,1\n</code></pre>"},{"location":"assembly/#ch395_get_socket_status_sn","title":"ch395_get_socket_status_sn","text":"<p>Description</p> <p>This command is used to get Socket status. It is necessary to input a 1 byte of Socket index value. CH395 will output a 2-byte status code when receiving this command. The first status code is the status code of Socket. The status code of Socket is defined as follows:</p> <p>00H SOCKET_CLOSED</p> <p>05H SOCKET_OPEN</p> <p>The second status code is TCP status code, which is only meaningful when TCP mode has been on. TCP</p> <p>status code is defined as follows:</p> <p>Code Name Description</p> <p>00H TCP_CLOSED Closed</p> <p>01H TCP_LISTEN Monitoring</p> <p>02H TCP_SYN_SENT SYN sent</p> <p>03H TCP_SYN_RCVD SYN received</p> <p>04H TCP_ESTABLISHED TCP connection established</p> <p>05H TCP_FIN_WAIT_1 The active closing side first sends FIN</p> <p>06H TCP_FIN_WAIT_2 The active closing side receives an ACK from FIN</p> <p>07H TCP_CLOSE_WAIT The passive closing side receives FIN</p> <p>08H TCP_CLOSING Closing</p> <p>09H TCP_LAST_ACK The passive closing side sends FIN</p> <p>0AH TCP_TIME_WAIT 2MLS waiting status</p> <p>TCP status is defined in TCP/IP protocol. Please refer to TCP/IP protocol for the detailed meaning</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>X Register </li> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The status</p> </li> <li> <p>X Register : The state</p> </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_socket_status_sn\n ; check A and X for the state\n cmp #CH395_SOCKET_CLOSED\n beq @soclet is closed\n</code></pre>"},{"location":"assembly/#ch395_get_unreach_ipport","title":"ch395_get_unreach_ipport","text":"<p>Description</p> <p>This command is used to get an inaccessible IP, ports and protocol type. CH395 will generate an inaccessible interrupt when an inaccessible message is received. MCU can use this command to get inaccessible information. After receiving this command, CH395 will output 1 byte of inaccessible code, 1 byte of protocol type, 2 bytes of port number (low bytes in front), and 4 bytes of IP in turn. MCU can judge whether the protocol, port or IP is inaccessible according to the inaccessible codes. For inaccessible codes, refer to RFC792 (CH395INC.H defines four common inaccessible codes).</p> <p>Does not work</p>"},{"location":"assembly/#ch395_init","title":"ch395_init","text":"<p>Description</p> <p>This command is used to initialize CH395, including initializing MAC, PHY and TCP/IP stack of CH395. Generally, it takes 350mS to execute the command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status.</p> <p>Modify</p> <ul> <li>Accumulator  Description</li> </ul> <p>Reset ch395</p> <p>Example</p> <pre><code> jsr ch395_init\n ; Wait a bit\n</code></pre>"},{"location":"assembly/#ch395_open_socket_sn","title":"ch395_open_socket_sn","text":"<p>Description</p> <p>This command is used to open Socket and use the necessary steps of Socket. It is necessary to input 1 byte of Socket index value. After sending this command, MCU shall send GET_CMD_STATUS to query the command execution status. After opening Socket in UDP, IPRAW or MACRAW mode and returning successfully, data transmission can be performed. Before this command is sent, necessary settings must be made for destination IP, protocol type, source port, destination port, etc. Please refer to 8.3 Application Reference Steps for detailed steps.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"assembly/#ch395_read_recv_buf_sn","title":"ch395_read_recv_buf_sn","text":"<p>Description</p> <p>This command is used to read data from Socket receive buffer. It is necessary to input 1 byte of Socket index value and 2 bytes of length (low bytes in front). CH395 will output several bytes of data stream based on the length value. In actual application, the command RECV_LEN_SN can be firstly sent to get the actual effective length of the current buffer. The length of the read data can be less than the actual effective length of the buffer, the unread data is still reserved in the receive buffer, and MCU can continue to read through this command. In MACRAW mode, the processing modes are different. In MACRAW mode, the receive buffer is a frame buffer, which can cache only 1 frame of Ethernet data. After CH395 processes the command READ_RECV_BUF_SN, Socket0 receive buffer will be cleared, so MCU shall read all valid data of the buffer at a time.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : Length low</li> <li>X Register : length high</li> <li>RES : ptr to fill</li> </ul> <p>Modify</p> <ul> <li>RESBtmp value</li> </ul>"},{"location":"assembly/#ch395_reset_all","title":"ch395_reset_all","text":"<p>Description</p> <p>This command enables CH395 to perform a hardware reset. Typically, hardware reset is completed within 50mS.</p> <p>Example</p> <pre><code> jsr ch395_reset_all\n ; Wait a bit\n</code></pre>"},{"location":"assembly/#ch395_set_baudrate","title":"ch395_set_baudrate","text":"<p>Description</p> <p>This command is used to set the baud rate of CH395 for serial communication. When CH395 works in serial communication mode, the default communication baud rate is set by the level combination of SDO, SDI and SCK pins (refer to Section 6.4 of this datasheet) after reset. When these pins are suspended, the baud rate is 9600bps by default. If MCU supports high communication speed, the serial communication baud rate can be dynamically regulated through this command. This command requires the input of three data, namely, baudrate coefficient 0, baud rate coefficient 1 and baud rate coefficient 2. The following table shows the corresponding relationship with baud rates.</p>"},{"location":"assembly/#ch395_set_des_port_sn","title":"ch395_set_des_port_sn","text":"<p>Description</p> <p>This command is used to set the Socket destination port. It is necessary to input 1 byte of Socket index value and 2 bytes of destination port (the low bytes are in front). When Socket works in UDP or TCP Client mode, this value must be set.</p> <p>Input</p> <ul> <li>Accumulator : Socketid </li> <li>Y Register : Low int</li> <li>X Register : high int</li> </ul> <p>Modify</p> <ul> <li>REStmp</li> </ul> <p>Example</p> <pre><code> lda #$01\n ldy #80\n ldx #$00\n jsr ch395_set_des_port_sn\n rts\n</code></pre>"},{"location":"assembly/#ch395_set_fun_para","title":"ch395_set_fun_para","text":"<p>Description</p> <p>Set fun para</p> <p>Input</p> <ul> <li>Accumulator : Value </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> <li>Accumulator </li> </ul>"},{"location":"assembly/#ch395_set_gwip_addr","title":"ch395_set_gwip_addr","text":"<p>Description</p> <p>This command is used to set the gateway address for CH395. It is necessary to input 4 bytes of IP address</p> <p>Does not work</p>"},{"location":"assembly/#ch395_set_ip_addr","title":"ch395_set_ip_addr","text":"<p>Description</p> <p>This command is used to set IP address for CH395. It is necessary to input 4 bytes of IP address, with low bytes of IP in front. For all commands including IP input or output in this datasheet, IP low bytes are in front. This will not be explained below</p> <p>Does not work</p>"},{"location":"assembly/#ch395_set_ip_addr_sn","title":"ch395_set_ip_addr_sn","text":"<p>Description</p> <p>This command is used to set the destination IP address of Socket. It is necessary to input 1 byte of Socket index value and 4 bytes of destination IP address. When Socket works in IPRAW, UDP, or TCP Client mode, 0the destination IP must be set before the command CMD_OPEN_SOCKET_SN is sent</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : low ptr ip</li> <li>X Register : high ptr ip</li> </ul> <p>Modify</p> <ul> <li>REStmp</li> </ul>"},{"location":"assembly/#ch395_set_ipraw_pro_sn","title":"ch395_set_ipraw_pro_sn","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>X Register : the mode proto</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"assembly/#ch395_set_mac_adress","title":"ch395_set_mac_adress","text":"<p>Description</p> <p>This command is used to set MAC address for CH395. It is necessary to input 6 bytes of MAC, with low bytes of MAC address in front. CH395 chip will store MAC address in the internal EEPROM. It will take 100mS to execute this command.MAC address assigned by IEEE has been burned when CH395 chip is delivered. If it is not necessary, please do not set MAC address</p> <p>Input</p> <ul> <li>Accumulator : Low ptr mac adress</li> <li>X Register : High ptr mac adress</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> <li>RESTmp</li> </ul>"},{"location":"assembly/#ch395_set_mac_filt","title":"ch395_set_mac_filt","text":"<p>Does not work</p>"},{"location":"assembly/#ch395_set_mask_addr","title":"ch395_set_mask_addr","text":"<p>Description</p> <p>This command is used to set the subnet mask for CH395. It is necessary to input 4 bytes of mask for this command. It is 255.255.255.0 by default and may not be set</p> <p>Does not work</p>"},{"location":"assembly/#ch395_set_phy","title":"ch395_set_phy","text":"<p>Description</p> <p>This command is used to set Ethernet PHY connection mode of CH395. The connection mode is automated negotiation mode by default. This command needs to input 1 byte of data, which is the connection mode code: Disconnect PHY when the connection mode code is 01H; PHY is 10M full duplex when the connection mode code is 02H; PHY is 10M half duplex when the connection mode code is 04H; PHY is 100M full duplex when the connection mode code is 08H; PHY is 100M half duplex when the connection mode code is 10H; PHY is automated negotiation when the connection mode code is 20H. When CH395 receives this command, it will reset MAC and PHY and reconnect according to the newly set connection mode. If Ethernet is already connected, it will be disconnected and reconnected.</p> <p>Does not work</p>"},{"location":"assembly/#ch395_set_proto_type_sn","title":"ch395_set_proto_type_sn","text":"<p>Description</p> <p>This command is used to set the working mode of Socket. It is necessary to input 1 byte of Socket index value and 1 byte of working mode. The working mode is defined as follows:</p> <p>Code Name Description</p> <p>03H PROTO_TYPE_TCP TCP mode</p> <p>02H PROTO_TYPE_UDP UDP mode</p> <p>01H PROTO_TYPE_MAC_RAW MAC original message mode</p> <p>00H PROTO_TYPE_IP_RAW IP original message mode</p> <p>This command must be executed before CMD_OPEN_SOCKET_SN. Refer to 8.3 Application Reference</p> <p>Steps for detailed steps.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>X Register : Proto mode</li> </ul> <p>Modify</p> <ul> <li>Y Register tmp</li> </ul> <p>Example</p> <pre><code> lda #$00 ; Socket\n ldx #CH395_PROTO_TYPE_TCP\n jsr ch395_set_proto_type_sn\n</code></pre>"},{"location":"assembly/#ch395_set_retran_count","title":"ch395_set_retran_count","text":"<p>Description</p> <p>This command is used to set the number of retries. It is necessary to input 1 byte of number of retries. The allowable maximum value is 20. If the input data is more than 20, it will be processed as 20. The default number of retries is 12, and retries are only valid in TCP mode.</p> <p>Input</p> <ul> <li>Accumulator : Retran period</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"assembly/#ch395_set_retran_period","title":"ch395_set_retran_period","text":"<p>Description</p> <p>This command is used to set the retry cycle. It is necessary to input 2 bytes of number of cycles of (with low bytes in front) in milliseconds. The allowable maximum value is 1000. The total retry time is N * M, N is the number of retries, and M is the retry cycle. The default retry cycle is 500MS and retries are only valid in TCP mode.</p> <p>Input</p> <ul> <li>Accumulator : Period </li> <li>X Register : Period </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$FF\n ldx #$FF\n jsr ch395_retran_period\n rts\n</code></pre>"},{"location":"assembly/#ch395_set_sour_port_sn","title":"ch395_set_sour_port_sn","text":"<p>Description</p> <p>This command is used to set the source port of Socket. It is necessary to input 1 byte of Socket index value and 2 bytes of source port (low bytes in front). If two or more Sockets are in the same mode, the source port numbers must not be the same. For example, Socket 0 is in UDP mode, the source port number is 600, and Socket 1 is also in UDP mode. The source port number 600 cannot be used again, otherwise it may cause the0 opening failure.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : Low port</li> <li>X Register : High port</li> </ul> <p>Modify</p> <ul> <li>RES</li> </ul>"},{"location":"assembly/#ch395_set_ttl","title":"ch395_set_ttl","text":"<p>Description</p> <p>This command is used to set Socket TTL. It is necessary to input 1 byte of Socket index value and 1 byte of TTL value. It shall be set after the Socket is opened, and the maximum value is 128</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>X Register : TTL value</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"assembly/#ch395_tcp_connect_sn","title":"ch395_tcp_connect_sn","text":"<p>Description</p> <p>Performs tcp connect</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"assembly/#ch395_tcp_disconnect_sn","title":"ch395_tcp_disconnect_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"assembly/#ch395_tcp_listen_sn","title":"ch395_tcp_listen_sn","text":"<p>Description</p> <p>This command is only valid in TCP mode, enabling the Socket to be in the monitoring mode, namely, TCP Server mode. It is necessary to input a 1 byte of Socket index value. This command must be executed after OPEN_SOCKET_SN. After sending this command, MCU shall send GET_CMD_STATUS to query the 0command execution status. In TCP Server mode, the Socket will always detect connection events, and the interrupt SINT_STAT_CONNECT will be generated until the connection is successful. Only one connection can be 0established for each Socket. If an eligible connection event is received again, Socket will send TCP RESET to the remote end tried to be connected.</p>"},{"location":"assembly/#ch395_write_send_buf_sn","title":"ch395_write_send_buf_sn","text":"<p>Description</p> <p>This command is used to write data to Socket transmit buffer. It is necessary to input 1 byte of Socket index value, 2 bytes of length (low bytes in front) and several bytes of data stream. The length of input data must not be larger than the size of transmit buffer. However, in MACRAW mode, the maximum length of input data can only be 1514, and any redundant data will be discarded. After the external MCU writes the data, CH395 will encapsulate the data packet according to the working mode of Socket, and then send it. Before MCU receives SINT_STAT_SENBUF_FREE, it is not allowed to write data into Socket transmit buffer again</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>Y Register : Low length</li> <li>X Register : High length</li> <li>RESB : Adress ptr to read</li> </ul> <p>Modify</p> <ul> <li>RESTmp</li> </ul> <p>Example</p>"},{"location":"c/","title":"C","text":""},{"location":"c/#c","title":"C","text":""},{"location":"c/#unsigned-char-ch395_check_exist","title":"unsigned char ch395_check_exist();","text":"<p>Description</p> <p>This command is used to test the communication interface and working state to check whether CH395 is working properly. This command needs to input 1 byte of data, which can be any data. If CH395 is working properly, the output data of CH395 will be the bitwise reverse of the input data. For example, if the input data is 57H, the output data will be A8H.</p>"},{"location":"c/#void-ch395_clear_recv_buf_snunsigned-char-id_socket","title":"void ch395_clear_recv_buf_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>This command is used to clear the Socket receive buffer. It is necessary to input 1 byte of Socket index value. Upon receiving this command, CH395 will reset the receiving length of this Socket, and the receiving pointer will point to the buffer head.</p>"},{"location":"c/#void-ch395_close_socket_snunsigned-char-socketid","title":"void ch395_close_socket_sn(unsigned char socketid)","text":"<p>Description</p> <p>This command is used to close Socket. It is necessary to input a 1 byte of Socket index value. After Socket is closed, the receive buffer and transmit buffer of Socket are emptied, but the configuration information is still reserved, and you just need to open the Socket again when using the Socket the next time. In TCP mode, CH395 will automatically disconnect TCP before turning off Socket.</p> <p>Input</p>"},{"location":"c/#void-ch395_dhcp_enable","title":"void ch395_dhcp_enable()","text":"<p>Description</p> <p>This command is used to start or stop DHCP. It is necessary to input a 1-byte flag. If the flag is 1, it will indicate that DHCP is on; if the flag is 0, it will indicate that DHCP is off. CH395 must be initialized before DHCP is started. After DHCP is started, CH395 will broadcast DHCPDISCOVER message to the network to discover DHCP Server, request the address and other configuration parameters after finding DHCP Server, and then generate GINT_STAT_DHCP interrupt. MCU can send GET_DHCP_STATUS command to get DHCP status. If the status code is 0, it will indicate success, and MCU can send the command GET_IP_INF to get IP, MASK and other information. If the status code is 1, it will indicate error, which is generally caused by timeout, for example, no DHCP Server is found. DHCP is always in a working state after startup unless it receives a DHCP shutdown command from MCU. During this process, if DHCP Server reassigns a configuration to CH395 and the configuration is different from the original configuration, CH395 will still generate an interrupt. After timeout interrupt is generated, if DHCP Server is not found, CH395 will continue to send DHCPDISCOVER message at an interval of about 16 seconds. It takes about 20MS to execute this command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status</p> <p>Description</p> <p>Get cmd status</p>"},{"location":"c/#unsigned-char-ch395_get_cmd_status","title":"unsigned char ch395_get_cmd_status();","text":""},{"location":"c/#unsigned-char-ch395_get_dhcp_status","title":"unsigned char ch395_get_dhcp_status();","text":"<p>Description</p> <p>Get dhcp status</p>"},{"location":"c/#unsigned-int-ch395_get_glob_int_status","title":"unsigned int ch395_get_glob_int_status();","text":"<p>Description</p> <p>Get General interrupt Status</p>"},{"location":"c/#unsigned-char-ch395_get_ic_ver","title":"unsigned char ch395_get_ic_ver();","text":"<p>Description</p> <p>This command is used to get the chip and firmware versions. 1 byte of data returned is the version number, the bit 7 is 0, the bit 6 is 1, and the bits 5-0 are the version number. If the returned value is 41H, remove bits 7 and 6, and the version number will be 01H. It is called chip version in this text</p>"},{"location":"c/#unsigned-char-ch395_get_int_status_snunsigned-char-id_socket","title":"unsigned char ch395_get_int_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Check interrupt socket status</p> <p>Input</p> <p>;;@inputA Socket id    ;;@modifyA    ;;@modifyX    ;;@returnsA Status of selected socket    ;;@<code>ca65    ;;@`  lda     #CH395_SOCKET1 ; Check socket 1    ;;@`  jsr     ch395_get_int_status_sn    ;;@`  ; Check interrupt type    ;;@`  and     #CH395_SINT_STAT_SEND_OK    ;;@`  cmp     #CH395_SINT_STAT_SEND_OK    ;;@`  beq     @send_ok    ;;@`  rts    ;;@</code> ldx     #CH395_GET_INT_STATUS_SN    stx     CH395_COMMAND_PORT    sta     CH395_DATA_PORT    lda     CH395_DATA_PORT    rts endproc</p>"},{"location":"c/#void-ch395_get_ip_infunsigned-char-ip_infos","title":"void ch395_get_ip_inf(unsigned char ip_infos[]);","text":"<p>Description</p> <p>Get ip info : ip_infos must be 20 bytes length)</p>"},{"location":"c/#void-ch395_get_mac_adressunsigned-char-macaddress","title":"void ch395_get_mac_adress(unsigned char macaddress[]);","text":"<p>Description</p> <p>Get mac address</p>"},{"location":"c/#unsigned-char-ch395_get_phy_status","title":"unsigned char ch395_get_phy_status();","text":"<p>Description</p> <p>Get physical status</p>"},{"location":"c/#void-ch395_get_recv_len_snunsigned-char-id_socket","title":"void ch395_get_recv_len_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p>"},{"location":"c/#void-ch395_get_remot_ipp_snunsigned-char-ptr-unsigned-char-socket","title":"void ch395_get_remot_ipp_sn(unsigned char *ptr, unsigned char socket);","text":"<p>Description</p> <p>Get remote ip connected to the socket</p> <p>Input</p>"},{"location":"c/#unsigned-int-ch395_get_socket_status_snunsigned-char-id_socket","title":"unsigned int ch395_get_socket_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Returns in A socket status (close/open ... )</p> <p>Input</p>"},{"location":"c/#void-ch395_init","title":"void ch395_init();","text":"<p>Description</p> <p>;;@brief This command is used to initialize CH395, including initializing MAC, PHY and TCP/IP stack of CH395. Generally, it takes 350mS to execute the command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status.</p>"},{"location":"c/#void-ch395_open_socket_snunsigned-char-id_socket","title":"void ch395_open_socket_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"c/#void-ch395_read_recv_buf_snunsigned-char-buffer-unsigned-int-ptr2unsigned-char-id_socket","title":"void ch395_read_recv_buf_sn(unsigned char *buffer, unsigned int ptr2,unsigned char ID_SOCKET);","text":"<p>Input</p>"},{"location":"c/#void-ch395_reset_all","title":"void ch395_reset_all()","text":"<p>Description</p> <p>Reset ch395</p>"},{"location":"c/#void-ch395_set_des_port_snunsigned-int-port-unsigned-char-id_socket","title":"void ch395_set_des_port_sn(unsigned int port, unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set dest port socket</p> <p>Input</p>"},{"location":"c/#void-ch395_set_fun_paraunsigned-char-flag","title":"void ch395_set_fun_para(unsigned char flag)","text":"<p>Description</p> <p>Set fun para</p> <p>Description</p> <p>Set gateway ip addr</p> <p>Description</p> <p>This command is used to set the destination IP address of Socket. It is necessary to input 1 byte of Socket index value and 4 bytes of destination IP address. When Socket works in IPRAW, UDP, or TCP Client mode, 0the destination IP must be set before the command CMD_OPEN_SOCKET_SN is sent</p>"},{"location":"c/#void-ch395_set_ip_addr_snunsigned-char-ip_addr-unsigned-char-id_socket","title":"void ch395_set_ip_addr_sn(unsigned char ip_addr[], unsigned char ID_SOCKET)","text":""},{"location":"c/#void-ch395_set_ipraw_pro_snunsigned-char-id_socket","title":"void ch395_set_ipraw_pro_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p>"},{"location":"c/#void-ch395_set_mac_adressunsigned-char-macaddress","title":"void ch395_set_mac_adress(unsigned char macaddress[]);","text":""},{"location":"c/#void-ch395_set_proto_type_snunsigned-char-proto-unsigned-char-id_socket","title":"void ch395_set_proto_type_sn(unsigned char proto, unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"c/#void-ch395_set_retran_countunsigned-int-period","title":"void ch395_set_retran_count(unsigned int period);","text":"<p>Description</p> <p>Set retran period</p>"},{"location":"c/#void-ch395_retran_periodunsigned-int-period","title":"void ch395_retran_period(unsigned int period);","text":"<p>Description</p> <p>Retran period</p>"},{"location":"c/#void-ch395_set_sour_port_snunsigned-int-portunsigned-char-id_socket","title":"void ch395_set_sour_port_sn(unsigned int port,unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Set source socket</p> <p>Input</p> <p>Description</p> <p>This command is used to set Socket TTL. It is necessary to input 1 byte of Socket index value and 1 byte of TTL value. It shall be set after the Socket is opened, and the maximum value is 128</p>"},{"location":"c/#ch395_set_ttlunsigned-char-id_socket-unsigned-char-ttl_value","title":"ch395_set_ttl(unsigned char ID_SOCKET, unsigned char ttl_value);","text":""},{"location":"c/#void-ch395_tcp_connect_snunsigned-char-id_socket","title":"void ch395_tcp_connect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"c/#void-ch395_tcp_disconnect_snunsigned-char-id_socket","title":"void ch395_tcp_disconnect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"c/#void-ch395_tcp_listen_snunsigned-char-id_socket","title":"void ch395_tcp_listen_sn(unsigned char ID_SOCKET)","text":""},{"location":"c/#void-ch395_write_send_buf_snunsigned-char-buffer-unsigned-int-lengthunsigned-char-id_socket","title":"void ch395_write_send_buf_sn(unsigned char *buffer, unsigned int length,unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Send data to socketid [Not working]</p> <p>Input</p>"},{"location":"2024.1/assembly/","title":"Assembly","text":""},{"location":"2024.1/assembly/#assembly","title":"Assembly","text":""},{"location":"2024.1/assembly/#ch395_check_exist","title":"ch395_check_exist","text":"<p>Description</p> <p>Checks if ch395 exists</p> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status\n cmp #CH395_DETECTED\n beq ch395_connected\n rts\nch395_connected:\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Returns #CH395_DETECTED if it exists</li> </ul>"},{"location":"2024.1/assembly/#ch395_clear_recv_buf_sn","title":"ch395_clear_recv_buf_sn","text":"<p>Description</p> <p>Clear receive buffer</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Socket ID\n jsr ch395_clear_recv_buf_sn\n</code></pre>"},{"location":"2024.1/assembly/#ch395_close_socket_sn","title":"ch395_close_socket_sn","text":"<p>Description</p> <p>Close socket</p> <p>Input</p> <ul> <li>Accumulator : The id of the socket to close</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket ID\n jsr ch395_close_socket_sn\n</code></pre>"},{"location":"2024.1/assembly/#ch395_dhcp_enable","title":"ch395_dhcp_enable","text":"<p>Description</p> <p>Enable or not dhcp</p> <p>Input</p> <ul> <li>Accumulator : The mode to activate DHCP mode</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_cmd_status","title":"ch395_get_cmd_status","text":"<p>Description</p> <p>Get cmd status</p> <p>Example</p> <pre><code> jsr ch395_get_cmd_status\n ; Check A for STATUS\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_dhcp_status","title":"ch395_get_dhcp_status","text":"<p>Description</p> <p>Get dhcp status</p> <p>Example</p> <pre><code> jsr ch395_get_dhcp_status\n ; Check A for dhcp status\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_glob_int_status","title":"ch395_get_glob_int_status","text":"<p>Description</p> <p>Get General interrupt Status</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status\n ; check accumulator to get interrupts states\n</code></pre>"},{"location":"2024.1/assembly/#ch395_get_ic_ver","title":"ch395_get_ic_ver","text":"<p>Description</p> <p>Get ch395 firmware version</p> <p>Example</p> <pre><code> jsr ch395_get_ic_ver\n ; Check A for version\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_int_status_sn","title":"ch395_get_int_status_sn","text":"<p>Description</p> <p>Check interrupt socket status</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Status of selected socket</li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Check socket 1\n jsr ch395_get_int_status_sn\n ; Check interrupt type\n rts\n</code></pre>"},{"location":"2024.1/assembly/#ch395_get_ip_inf","title":"ch395_get_ip_inf","text":"<p>Description</p> <p>Get ip info</p> <p>Input</p> <ul> <li>Accumulator : the ptr to modify</li> <li>X Register : the ptr to modify</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_mac_adress","title":"ch395_get_mac_adress","text":"<p>Description</p> <p>Get mac address</p> <p>Input</p> <ul> <li>Accumulator : the ptr</li> <li>X Register : the ptr</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : the content of ptr modified</p> </li> <li> <p>X Register : the content of ptr modified</p> </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_phy_status","title":"ch395_get_phy_status","text":"<p>Description</p> <p>Get physical status</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : The physical status</li> </ul> <p>Example</p> <pre><code> jsr ch395_get_phy_status\n ; Check A physical status\n rts\n</code></pre>"},{"location":"2024.1/assembly/#ch395_get_recv_len_sn","title":"ch395_get_recv_len_sn","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_recv_len_sn\n ; check A and X for length received\nch395_connected:\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The length</p> </li> <li> <p>X Register : The length</p> </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_remot_ipp_sn","title":"ch395_get_remot_ipp_sn","text":"<p>Description</p> <p>Get remote ip connected to the socket</p> <p>Input</p> <ul> <li>Accumulator : The Socket for the ip to get</li> <li>X Register : The ptr (high) to store the ip</li> <li>Y Register : The ptr (low) to store the ip</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> </ul>"},{"location":"2024.1/assembly/#ch395_get_socket_status_sn","title":"ch395_get_socket_status_sn","text":"<p>Description</p> <p>Returns in A socket status (close/open ...)</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>X Register </li> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The status</p> </li> <li> <p>X Register : The state</p> </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_socket_status_sn\n ; check A and X for the state\n</code></pre>"},{"location":"2024.1/assembly/#ch395_init","title":"ch395_init","text":"<p>Description</p> <p>Initialize ch395</p> <p>Modify</p> <ul> <li>Accumulator  Description</li> </ul> <p>Reset ch395</p> <p>Example</p> <pre><code> jsr ch395_init\n ; Wait a bit\n</code></pre>"},{"location":"2024.1/assembly/#ch395_open_socket_sn","title":"ch395_open_socket_sn","text":"<p>Description</p> <p>Open socket from arg</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.1/assembly/#ch395_read_recv_buf_sn","title":"ch395_read_recv_buf_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_reset_all","title":"ch395_reset_all","text":"<p>Description</p> <p>Reset ch395</p> <p>Example</p> <pre><code> jsr ch395_reset_all\n ; Wait a bit\n</code></pre>"},{"location":"2024.1/assembly/#ch395_retran_period","title":"ch395_retran_period","text":"<p>Description</p> <p>Retran period</p> <p>Input</p> <ul> <li>Accumulator : Period </li> <li>X Register : Period </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$FF\n ldx #$FF\n jsr ch395_retran_period\n rts\n</code></pre>"},{"location":"2024.1/assembly/#ch395_set_des_port_sn","title":"ch395_set_des_port_sn","text":"<p>Description</p> <p>Set dest port socket</p> <p>Input</p> <ul> <li>Accumulator : Socketid </li> <li>Y Register : Low int</li> <li>X Register : high int</li> </ul> <p>Example</p> <pre><code> lda #$01\n ldx #80\n ldx #$00\n jsr ch395_set_des_port_sn\n rts\n</code></pre>"},{"location":"2024.1/assembly/#ch395_set_fun_para","title":"ch395_set_fun_para","text":"<p>Description</p> <p>Set fun para</p> <p>Input</p> <ul> <li>Accumulator : Value </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> <li>Accumulator </li> </ul>"},{"location":"2024.1/assembly/#ch395_set_gwip_addr","title":"ch395_set_gwip_addr","text":"<p>Description</p> <p>Set gateway ip addr</p>"},{"location":"2024.1/assembly/#ch395_set_ip_addr","title":"ch395_set_ip_addr","text":"<p>Description</p> <p>Set ip row</p>"},{"location":"2024.1/assembly/#ch395_set_ip_addr_sn","title":"ch395_set_ip_addr_sn","text":"<p>Description</p> <p>Set Socket Ip address to connect with</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_set_ipraw_pro_sn","title":"ch395_set_ipraw_pro_sn","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_set_mac_adress","title":"ch395_set_mac_adress","text":"<p>Description</p> <p>Set mac address</p>"},{"location":"2024.1/assembly/#ch395_set_proto_type_sn","title":"ch395_set_proto_type_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_set_retran_count","title":"ch395_set_retran_count","text":"<p>Description</p> <p>Set retran period</p> <p>Input</p> <ul> <li>Accumulator : Retran period</li> </ul>"},{"location":"2024.1/assembly/#ch395_set_sour_port_sn","title":"ch395_set_sour_port_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_tcp_connect_sn","title":"ch395_tcp_connect_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_tcp_disconnect_sn","title":"ch395_tcp_disconnect_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.1/assembly/#ch395_tcp_listen_sn","title":"ch395_tcp_listen_sn","text":"<p>Description</p> <p>TCP listen socket</p>"},{"location":"2024.1/assembly/#ch395_write_send_buf_sn","title":"ch395_write_send_buf_sn","text":"<p>Description</p> <p>Send data to socketid</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>Y Register : Low length</li> <li>X Register : High length</li> </ul>"},{"location":"2024.1/c/","title":"C","text":""},{"location":"2024.1/c/#c","title":"C","text":""},{"location":"2024.1/c/#unsigned-char-ch395_check_exist","title":"unsigned char ch395_check_exist();","text":"<p>Description</p> <p>Checks if ch395 exists</p>"},{"location":"2024.1/c/#void-ch395_clear_recv_buf_snunsigned-char-id_socket","title":"void ch395_clear_recv_buf_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Clear receive buffer</p>"},{"location":"2024.1/c/#oid-ch395_close_socket_snunsigned-char-socketid","title":"oid ch395_close_socket_sn(unsigned char socketid)","text":"<p>Description</p> <p>Close socket</p> <p>Input</p>"},{"location":"2024.1/c/#unsigned-char-ch395_get_dhcp_status","title":"unsigned char ch395_get_dhcp_status();","text":"<p>Description</p> <p>Get dhcp status</p>"},{"location":"2024.1/c/#unsigned-int-ch395_get_glob_int_status","title":"unsigned int ch395_get_glob_int_status();","text":"<p>Description</p> <p>Get General interrupt Status</p>"},{"location":"2024.1/c/#unsigned-char-ch395_get_ic_ver","title":"unsigned char ch395_get_ic_ver();","text":"<p>Description</p> <p>Get ch395 firmware version</p>"},{"location":"2024.1/c/#unsigned-char-ch395_get_int_status_snunsigned-char-id_socket","title":"unsigned char ch395_get_int_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Check interrupt socket status</p> <p>Input</p>"},{"location":"2024.1/c/#void-ch395_get_ip_infunsigned-char-ip_infos","title":"void ch395_get_ip_inf(unsigned char ip_infos[]);","text":"<p>Description</p> <p>Get ip info</p>"},{"location":"2024.1/c/#void-ch395_get_mac_adressunsigned-char-macaddress","title":"void ch395_get_mac_adress(unsigned char macaddress[]);","text":"<p>Description</p> <p>Get mac address</p>"},{"location":"2024.1/c/#unsigned-char-ch395_get_phy_status","title":"unsigned char ch395_get_phy_status();","text":"<p>Description</p> <p>Get physical status</p>"},{"location":"2024.1/c/#void-ch395_get_recv_len_snunsigned-char-id_socket","title":"void ch395_get_recv_len_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p>"},{"location":"2024.1/c/#void-ch395_get_remot_ipp_snunsigned-char-ptr-unsigned-char-socket","title":"void ch395_get_remot_ipp_sn(unsigned char *ptr, unsigned char socket);","text":"<p>Description</p> <p>Get remote ip connected to the socket</p> <p>Input</p>"},{"location":"2024.1/c/#unsigned-int-ch395_get_socket_status_snunsigned-char-id_socket","title":"unsigned int ch395_get_socket_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Returns in A socket status (close/open ... )</p> <p>Input</p>"},{"location":"2024.1/c/#void-ch395_init","title":"void ch395_init();","text":"<p>Description</p> <p>Initialize ch395</p>"},{"location":"2024.1/c/#void-ch395_open_socket_snunsigned-char-id_socket","title":"void ch395_open_socket_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.1/c/#void-ch395_read_recv_buf_snunsigned-char-buffer-unsigned-int-lengthunsigned-char-id_socket","title":"void ch395_read_recv_buf_sn(unsigned char *buffer, unsigned int length,unsigned char ID_SOCKET);","text":"<p>Input</p>"},{"location":"2024.1/c/#void-ch395_reset_all","title":"void ch395_reset_all()","text":"<p>Description</p> <p>Reset ch395</p>"},{"location":"2024.1/c/#void-ch395_retran_periodunsigned-int-period","title":"void ch395_retran_period(unsigned int period);","text":"<p>Description</p> <p>Retran period</p>"},{"location":"2024.1/c/#void-ch395_set_des_port_snunsigned-int-port-unsigned-char-id_socket","title":"void ch395_set_des_port_sn(unsigned int port, unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set dest port socket</p> <p>Input</p>"},{"location":"2024.1/c/#void-ch395_set_fun_paraunsigned-char-flag","title":"void ch395_set_fun_para(unsigned char flag)","text":"<p>Description</p> <p>Set fun para</p> <p>Description</p> <p>Set gateway ip addr</p> <p>Description</p> <p>Set ip addr</p>"},{"location":"2024.1/c/#void-ch395_set_ip_addr_snunsigned-char-ip_addr-unsigned-char-id_socket","title":"void ch395_set_ip_addr_sn(unsigned char ip_addr[], unsigned char ID_SOCKET)","text":""},{"location":"2024.1/c/#void-ch395_set_ipraw_pro_snunsigned-char-id_socket","title":"void ch395_set_ipraw_pro_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p>"},{"location":"2024.1/c/#void-ch395_set_mac_adressunsigned-char-macaddress","title":"void ch395_set_mac_adress(unsigned char macaddress[]);","text":""},{"location":"2024.1/c/#void-ch395_set_proto_type_snunsigned-char-protounsigned-char-id_socket","title":"void ch395_set_proto_type_sn(unsigned char proto,unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.1/c/#void-ch395_set_retran_countunsigned-int-period","title":"void ch395_set_retran_count(unsigned int period);","text":"<p>Description</p> <p>Set retran period</p>"},{"location":"2024.1/c/#void-ch395_set_sour_port_snunsigned-int-portunsigned-char-id_socket","title":"void ch395_set_sour_port_sn(unsigned int port,unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Set source socket</p> <p>Input</p>"},{"location":"2024.1/c/#void-ch395_tcp_connect_snunsigned-char-id_socket","title":"void ch395_tcp_connect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.1/c/#void-ch395_tcp_disconnect_snunsigned-char-id_socket","title":"void ch395_tcp_disconnect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.1/c/#void-ch395_tcp_listen_snunsigned-char-id_socket","title":"void ch395_tcp_listen_sn(unsigned char ID_SOCKET)","text":""},{"location":"2024.1/c/#void-ch395_write_send_buf_snunsigned-char-buffer-unsigned-int-lengthunsigned-char-id_socket","title":"void ch395_write_send_buf_sn(unsigned char *buffer, unsigned int length,unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Send data to socketid</p> <p>Input</p>"},{"location":"2024.2/assembly/","title":"Assembly","text":""},{"location":"2024.2/assembly/#assembly","title":"Assembly","text":""},{"location":"2024.2/assembly/#ch395_check_exist","title":"ch395_check_exist","text":"<p>Description</p> <p>This command is used to test the communication interface and working state to check whether CH395 is working properly. This command needs to input 1 byte of data, which can be any data. If CH395 is working properly, the output data of CH395 will be the bitwise reverse of the input data. For example, if the input data is 57H, the output data will be A8H.</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Returns '#CH395_DETECTED' if it exists</li> </ul> <p>Example</p> <pre><code> jsr ch395_check_exist\n cmp #CH395_DETECTED\n beq ch395_connected\n rts\nch395_connected:\n</code></pre>"},{"location":"2024.2/assembly/#ch395_clear_recv_buf_sn","title":"ch395_clear_recv_buf_sn","text":"<p>Description</p> <p>This command is used to clear the Socket receive buffer. It is necessary to input 1 byte of Socket index value. Upon receiving this command, CH395 will reset the receiving length of this Socket, and the receiving pointer will point to the buffer head.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Socket ID\n jsr ch395_clear_recv_buf_sn\n</code></pre>"},{"location":"2024.2/assembly/#ch395_close_socket_sn","title":"ch395_close_socket_sn","text":"<p>Description</p> <p>This command is used to close Socket. It is necessary to input a 1 byte of Socket index value. After Socket is closed, the receive buffer and transmit buffer of Socket are emptied, but the configuration information is still reserved, and you just need to open the Socket again when using the Socket the next time. In TCP mode, CH395 will automatically disconnect TCP before turning off Socket.</p> <p>Input</p> <ul> <li>Accumulator : The id of the socket to close</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket ID\n jsr ch395_close_socket_sn\n</code></pre>"},{"location":"2024.2/assembly/#ch395_dhcp_enable","title":"ch395_dhcp_enable","text":"<p>Description</p> <p>This command is used to start or stop DHCP. It is necessary to input a 1-byte flag. If the flag is 1, it will indicate that DHCP is on; if the flag is 0, it will indicate that DHCP is off. CH395 must be initialized before DHCP is started. After DHCP is started, CH395 will broadcast DHCPDISCOVER message to the network to discover DHCP Server, request the address and other configuration parameters after finding DHCP Server, and then generate GINT_STAT_DHCP interrupt. MCU can send GET_DHCP_STATUS command to get DHCP status. If the status code is 0, it will indicate success, and MCU can send the command GET_IP_INF to get IP, MASK and other information. If the status code is 1, it will indicate error, which is generally caused by timeout, for example, no DHCP Server is found. DHCP is always in a working state after startup unless it receives a DHCP shutdown command from MCU. During this process, if DHCP Server reassigns a configuration to CH395 and the configuration is different from the original configuration, CH395 will still generate an interrupt. After timeout interrupt is generated, if DHCP Server is not found, CH395 will continue to send DHCPDISCOVER message at an interval of about 16 seconds. It takes about 20MS to execute this command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status</p> <p>Input</p> <ul> <li>Accumulator : The mode to activate DHCP mode</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"2024.2/assembly/#ch395_enter_sleep","title":"ch395_enter_sleep","text":"<p>Description</p> <p>This command enables CH395 chip in a low-power sleep suspended state. When MCU writes a new command to CH395 (no data input command, such as CMD_GET_IC_VER), it will exit the low-power state. For the parallel port and SPI interface communication modes, active SCS chip selection will also cause CH395 to exit the low-power state, so MCU shall immediately disable the SCS chip selection after sending the command CMD_ENTER_SLEEP. In sleep state, MAC and PHY of CH395 will be in power off mode and disconnect Ethernet. Typically, it takes several milliseconds for CH395 to exit the low-power state.</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_get_cmd_status","title":"ch395_get_cmd_status","text":"<p>Description</p> <p>This command is used to get the command execution status. CH395 will output 1 byte of data, which is the command execution state. The command execution status is as follows:</p> <p>Example</p> <pre><code> jsr ch395_get_cmd_status\n ; Check A for STATUS\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.2/assembly/#ch395_get_dhcp_status","title":"ch395_get_dhcp_status","text":"<p>Description</p> <p>Get dhcp status</p> <p>Example</p> <pre><code> jsr ch395_get_dhcp_status\n ; Check A for dhcp status\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.2/assembly/#ch395_get_glob_int_status_all","title":"ch395_get_glob_int_status_all","text":"<p>Description</p> <p>This command is used to get the global interrupt status. CH395 will output 2 bytes of global interrupt status after receiving this command. Global interrupt status is defined as follows:</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_get_glob_int_status","title":"ch395_get_glob_int_status","text":"<p>Description</p> <p>This command is used to get the global interrupt status. CH395 will output 1 byte of global interrupt status after receiving this command. Global interrupt status is defined as follows:</p> <p>Bit Name Description</p> <p>7 GINT_STAT_SOCK3 Socket3 interrupt</p> <p>6 GINT_STAT_SOCK2 Socket2 interrupt</p> <p>5 GINT_STAT_SOCK1 Socket1 interrupt</p> <p>4 GINT_STAT_SOCK0 Socket0 interrupt</p> <p>3 GINT_STAT_DHCP DHCP interrupt</p> <p>2 GINT_STAT_PHY_CHANGE PHY status change interrupt</p> <p>1 GINT_STAT_IP_CONFLI IP conflict</p> <p>0 GINT_STAT_UNREACH Inaccessible interrupt</p> <p>\u2460 GINT_STAT_UNREACH: Inaccessible interrupt. When CH395 receives ICMP inaccessible interrupt</p> <p>message, it saves the IP address, port and protocol type of the inaccessible IP packet in the inaccessible</p> <p>information table, and then generates an interrupt. When the MCU receives the interrupt, it can send the</p> <p>command GET_UNREACH_IPPORT to get the inaccessible information.</p> <p>\u2461 GINT_STAT_IP_CONFLI: IP conflict interrupt. This interrupt is generated when CH395 detects that its</p> <p>IP address is the same as that of other network devices in the same network segment.</p> <p>\u2462 GINT_STAT_PHY_CHANGE: PHY change interrupt. This interrupt is generated when PHY connection</p> <p>of CH395 changes, for example, PHY state changes from the connected state to the disconnected state or</p> <p>from the disconnected state to the connected state. MCU can send GET_PHY_STATUS command to get</p> <p>the current PHY connection status.</p> <p>\u2463 GINT_STAT_DHCP: DHCP interrupt. If MCU enables DHCP function of CH395, CH395 will generate</p> <p>this interrupt. MCU can send the command CMD_GET_DHCP_STATUS to get the DHCP status. If the</p> <p>status is 0, it will indicate success; otherwise, it will indicate timeout failure.</p> <p>\u2464 GINT_STAT_SOCK0 - GINT_STAT_SOCK3: Socket interrupt. When there is an interrupt event in</p> <p>Socket, CH395 will generate this interrupt. MCU needs to send GET_INT_STATUS_SN to get the</p> <p>interrupt status of Socket. Please refer to GET_INT_STATUS_SN.</p> <p>When this command is completed, CH395 will set INT# pin to high level and clear the global interrupt</p> <p>status</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Status </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status\n ; check accumulator to get interrupts states\n</code></pre>"},{"location":"2024.2/assembly/#ch395_get_ic_ver","title":"ch395_get_ic_ver","text":"<p>Description</p> <p>This command is used to get the chip and firmware versions. 1 byte of data returned is the version number, the bit 7 is 0, the bit 6 is 1, and the bits 5-0 are the version number. If the returned value is 41H, remove bits 7 and 6, and the version number will be 01H. It is called chip version in this text</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Version </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_ic_ver\n ; Check A for version\n rts\n</code></pre>"},{"location":"2024.2/assembly/#ch395_get_int_status_sn","title":"ch395_get_int_status_sn","text":"<p>Description</p> <p>This command is used to get the interrupt status of Socket. It is necessary to input 1 byte of Socket index value. After receiving this command, CH395 will output 1 byte of Socket interrupt code. The interrupt code bits are defined as follows:</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Status of selected socket</li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Check socket 1\n jsr ch395_get_int_status_sn\n ; Check interrupt type\n and #CH395_SINT_STAT_SEND_OK\n cmp #CH395_SINT_STAT_SEND_OK\n beq @send_ok\n rts\n</code></pre>"},{"location":"2024.2/assembly/#ch395_get_ip_inf","title":"ch395_get_ip_inf","text":"<p>Description</p> <p>Get ip info</p> <p>Input</p> <ul> <li>Accumulator : the ptr to modify (Ptr must be 20 bytes length)</li> <li>X Register : the ptr to modify (Ptr must be 20 bytes length)</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RESTmp value</li> </ul>"},{"location":"2024.2/assembly/#ch395_get_mac_adress","title":"ch395_get_mac_adress","text":"<p>Description</p> <p>Get mac address</p> <p>Input</p> <ul> <li>Accumulator : the ptr</li> <li>X Register : the ptr</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RESTmp value</li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : the content of ptr modified</p> </li> <li> <p>X Register : the content of ptr modified</p> </li> </ul>"},{"location":"2024.2/assembly/#ch395_get_phy_status","title":"ch395_get_phy_status","text":"<p>Description</p> <p>This command is used to get PHY connection status. After receiving this command, CH395 will query the current PHY connection status and output 1-byte PHY connection status code: PHY is disconnected when the connection status code is 01H; PHY connection is 10M full duplex when the connection status code is 02H; PHY connection is 10M half duplex when the connection status code is 04H. PHY connection is 100M full duplex when the connection status code is 08H; PHY connection is 100M half duplex when the connection status code is 10H</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : The physical status</li> </ul> <p>Example</p> <pre><code> jsr ch395_get_phy_status\n ; Check A physical status\n rts\n</code></pre>"},{"location":"2024.2/assembly/#ch395_get_recv_len_sn","title":"ch395_get_recv_len_sn","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_recv_len_sn\n ; check A and X for length received\nch395_connected:\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The length</p> </li> <li> <p>X Register : The length</p> </li> </ul>"},{"location":"2024.2/assembly/#ch395_get_remot_ipp_sn","title":"ch395_get_remot_ipp_sn","text":"<p>Description</p> <p>This command is used to get the remote IP address and port number. It is necessary to input 1 byte of Socket index value. CH395 will output 4 bytes of IP address and 2 bytes of port number (low bytes in front). After Socket works in TCP Server mode and the connection is established, MCU can get the remote IP address and port number through this command</p> <p>Input</p> <ul> <li>Accumulator : The Socket for the ip to get</li> <li>X Register : The ptr (high) to store the ip</li> <li>Y Register : The ptr (low) to store the ip</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RES</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n ldx #&lt;ip_dest\n ldy #&gt;ip_dest\n jsr ch395_get_remot_ipp_sn\n rts\nipdest:\n .byte 192,168,0,1\n</code></pre>"},{"location":"2024.2/assembly/#ch395_get_socket_status_sn","title":"ch395_get_socket_status_sn","text":"<p>Description</p> <p>This command is used to get Socket status. It is necessary to input a 1 byte of Socket index value. CH395 will output a 2-byte status code when receiving this command. The first status code is the status code of Socket. The status code of Socket is defined as follows:</p> <p>00H SOCKET_CLOSED</p> <p>05H SOCKET_OPEN</p> <p>The second status code is TCP status code, which is only meaningful when TCP mode has been on. TCP</p> <p>status code is defined as follows:</p> <p>Code Name Description</p> <p>00H TCP_CLOSED Closed</p> <p>01H TCP_LISTEN Monitoring</p> <p>02H TCP_SYN_SENT SYN sent</p> <p>03H TCP_SYN_RCVD SYN received</p> <p>04H TCP_ESTABLISHED TCP connection established</p> <p>05H TCP_FIN_WAIT_1 The active closing side first sends FIN</p> <p>06H TCP_FIN_WAIT_2 The active closing side receives an ACK from FIN</p> <p>07H TCP_CLOSE_WAIT The passive closing side receives FIN</p> <p>08H TCP_CLOSING Closing</p> <p>09H TCP_LAST_ACK The passive closing side sends FIN</p> <p>0AH TCP_TIME_WAIT 2MLS waiting status</p> <p>TCP status is defined in TCP/IP protocol. Please refer to TCP/IP protocol for the detailed meaning</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>X Register </li> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The status</p> </li> <li> <p>X Register : The state</p> </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_socket_status_sn\n ; check A and X for the state\n cmp #CH395_SOCKET_CLOSED\n beq @soclet is closed\n</code></pre>"},{"location":"2024.2/assembly/#ch395_get_unreach_ipport","title":"ch395_get_unreach_ipport","text":"<p>Description</p> <p>This command is used to get an inaccessible IP, ports and protocol type. CH395 will generate an inaccessible interrupt when an inaccessible message is received. MCU can use this command to get inaccessible information. After receiving this command, CH395 will output 1 byte of inaccessible code, 1 byte of protocol type, 2 bytes of port number (low bytes in front), and 4 bytes of IP in turn. MCU can judge whether the protocol, port or IP is inaccessible according to the inaccessible codes. For inaccessible codes, refer to RFC792 (CH395INC.H defines four common inaccessible codes).</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_init","title":"ch395_init","text":"<p>Description</p> <p>This command is used to initialize CH395, including initializing MAC, PHY and TCP/IP stack of CH395. Generally, it takes 350mS to execute the command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status.</p> <p>Modify</p> <ul> <li>Accumulator  Description</li> </ul> <p>Reset ch395</p> <p>Example</p> <pre><code> jsr ch395_init\n ; Wait a bit\n</code></pre>"},{"location":"2024.2/assembly/#ch395_open_socket_sn","title":"ch395_open_socket_sn","text":"<p>Description</p> <p>This command is used to open Socket and use the necessary steps of Socket. It is necessary to input 1 byte of Socket index value. After sending this command, MCU shall send GET_CMD_STATUS to query the command execution status. After opening Socket in UDP, IPRAW or MACRAW mode and returning successfully, data transmission can be performed. Before this command is sent, necessary settings must be made for destination IP, protocol type, source port, destination port, etc. Please refer to 8.3 Application Reference Steps for detailed steps.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.2/assembly/#ch395_read_recv_buf_sn","title":"ch395_read_recv_buf_sn","text":"<p>Description</p> <p>This command is used to read data from Socket receive buffer. It is necessary to input 1 byte of Socket index value and 2 bytes of length (low bytes in front). CH395 will output several bytes of data stream based on the length value. In actual application, the command RECV_LEN_SN can be firstly sent to get the actual effective length of the current buffer. The length of the read data can be less than the actual effective length of the buffer, the unread data is still reserved in the receive buffer, and MCU can continue to read through this command. In MACRAW mode, the processing modes are different. In MACRAW mode, the receive buffer is a frame buffer, which can cache only 1 frame of Ethernet data. After CH395 processes the command READ_RECV_BUF_SN, Socket0 receive buffer will be cleared, so MCU shall read all valid data of the buffer at a time.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : Length low</li> <li>X Register : length high</li> <li>RES : tr to fill</li> </ul> <p>Modify</p> <ul> <li>RESBtmp value</li> </ul>"},{"location":"2024.2/assembly/#ch395_reset_all","title":"ch395_reset_all","text":"<p>Description</p> <p>This command enables CH395 to perform a hardware reset. Typically, hardware reset is completed within 50mS.</p> <p>Example</p> <pre><code> jsr ch395_reset_all\n ; Wait a bit\n</code></pre>"},{"location":"2024.2/assembly/#ch395_set_baudrate","title":"ch395_set_baudrate","text":"<p>Description</p> <p>This command is used to set the baud rate of CH395 for serial communication. When CH395 works in serial communication mode, the default communication baud rate is set by the level combination of SDO, SDI and SCK pins (refer to Section 6.4 of this datasheet) after reset. When these pins are suspended, the baud rate is 9600bps by default. If MCU supports high communication speed, the serial communication baud rate can be dynamically regulated through this command. This command requires the input of three data, namely, baudrate coefficient 0, baud rate coefficient 1 and baud rate coefficient 2. The following table shows the corresponding relationship with baud rates.</p>"},{"location":"2024.2/assembly/#ch395_set_des_port_sn","title":"ch395_set_des_port_sn","text":"<p>Description</p> <p>This command is used to set the Socket destination port. It is necessary to input 1 byte of Socket index value and 2 bytes of destination port (the low bytes are in front). When Socket works in UDP or TCP Client mode, this value must be set.</p> <p>Input</p> <ul> <li>Accumulator : Socketid </li> <li>Y Register : Low int</li> <li>X Register : high int</li> </ul> <p>Modify</p> <ul> <li>REStmp</li> </ul> <p>Example</p> <pre><code> lda #$01\n ldy #80\n ldx #$00\n jsr ch395_set_des_port_sn\n rts\n</code></pre>"},{"location":"2024.2/assembly/#ch395_set_fun_para","title":"ch395_set_fun_para","text":"<p>Description</p> <p>Set fun para</p> <p>Input</p> <ul> <li>Accumulator : Value </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> <li>Accumulator </li> </ul>"},{"location":"2024.2/assembly/#ch395_set_gwip_addr","title":"ch395_set_gwip_addr","text":"<p>Description</p> <p>This command is used to set the gateway address for CH395. It is necessary to input 4 bytes of IP address</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_set_ip_addr","title":"ch395_set_ip_addr","text":"<p>Description</p> <p>This command is used to set IP address for CH395. It is necessary to input 4 bytes of IP address, with low bytes of IP in front. For all commands including IP input or output in this datasheet, IP low bytes are in front. This will not be explained below</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_set_ip_addr_sn","title":"ch395_set_ip_addr_sn","text":"<p>Description</p> <p>This command is used to set the destination IP address of Socket. It is necessary to input 1 byte of Socket index value and 4 bytes of destination IP address. When Socket works in IPRAW, UDP, or TCP Client mode, 0the destination IP must be set before the command CMD_OPEN_SOCKET_SN is sent</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : low ptr ip</li> <li>X Register : high ptr ip</li> </ul> <p>Modify</p> <ul> <li>REStmp</li> </ul>"},{"location":"2024.2/assembly/#ch395_set_ipraw_pro_sn","title":"ch395_set_ipraw_pro_sn","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>X Register : the mode proto</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.2/assembly/#ch395_set_mac_adress","title":"ch395_set_mac_adress","text":"<p>Description</p> <p>This command is used to set MAC address for CH395. It is necessary to input 6 bytes of MAC, with low bytes of MAC address in front. CH395 chip will store MAC address in the internal EEPROM. It will take 100mS to execute this command.MAC address assigned by IEEE has been burned when CH395 chip is delivered. If it is not necessary, please do not set MAC address</p> <p>Input</p> <ul> <li>Accumulator : Low ptr mac adress</li> <li>X Register : High ptr mac adress</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> <li>RESTmp</li> </ul>"},{"location":"2024.2/assembly/#ch395_set_mac_filt","title":"ch395_set_mac_filt","text":"<p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_set_mask_addr","title":"ch395_set_mask_addr","text":"<p>Description</p> <p>This command is used to set the subnet mask for CH395. It is necessary to input 4 bytes of mask for this command. It is 255.255.255.0 by default and may not be set</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_set_phy","title":"ch395_set_phy","text":"<p>Description</p> <p>This command is used to set Ethernet PHY connection mode of CH395. The connection mode is automated negotiation mode by default. This command needs to input 1 byte of data, which is the connection mode code: Disconnect PHY when the connection mode code is 01H; PHY is 10M full duplex when the connection mode code is 02H; PHY is 10M half duplex when the connection mode code is 04H; PHY is 100M full duplex when the connection mode code is 08H; PHY is 100M half duplex when the connection mode code is 10H; PHY is automated negotiation when the connection mode code is 20H. When CH395 receives this command, it will reset MAC and PHY and reconnect according to the newly set connection mode. If Ethernet is already connected, it will be disconnected and reconnected.</p> <p>Does not work</p>"},{"location":"2024.2/assembly/#ch395_set_proto_type_sn","title":"ch395_set_proto_type_sn","text":"<p>Description</p> <p>This command is used to set the working mode of Socket. It is necessary to input 1 byte of Socket index value and 1 byte of working mode. The working mode is defined as follows:</p> <p>Code Name Description</p> <p>03H PROTO_TYPE_TCP TCP mode</p> <p>02H PROTO_TYPE_UDP UDP mode</p> <p>01H PROTO_TYPE_MAC_RAW MAC original message mode</p> <p>00H PROTO_TYPE_IP_RAW IP original message mode</p> <p>This command must be executed before CMD_OPEN_SOCKET_SN. Refer to 8.3 Application Reference</p> <p>Steps for detailed steps.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>X Register : Proto mode</li> </ul> <p>Modify</p> <ul> <li>Y Register tmp</li> </ul> <p>Example</p> <pre><code> lda #$00 ; Socket\n ldx #CH395_PROTO_TYPE_TCP\n jsr ch395_set_proto_type_sn\n</code></pre>"},{"location":"2024.2/assembly/#ch395_set_retran_count","title":"ch395_set_retran_count","text":"<p>Description</p> <p>This command is used to set the number of retries. It is necessary to input 1 byte of number of retries. The allowable maximum value is 20. If the input data is more than 20, it will be processed as 20. The default number of retries is 12, and retries are only valid in TCP mode.</p> <p>Input</p> <ul> <li>Accumulator : Retran period</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"2024.2/assembly/#ch395_set_retran_period","title":"ch395_set_retran_period","text":"<p>Description</p> <p>This command is used to set the retry cycle. It is necessary to input 2 bytes of number of cycles of (with low bytes in front) in milliseconds. The allowable maximum value is 1000. The total retry time is N * M, N is the number of retries, and M is the retry cycle. The default retry cycle is 500MS and retries are only valid in TCP mode.</p> <p>Input</p> <ul> <li>Accumulator : Period </li> <li>X Register : Period </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$FF\n ldx #$FF\n jsr ch395_retran_period\n rts\n</code></pre>"},{"location":"2024.2/assembly/#ch395_set_sour_port_sn","title":"ch395_set_sour_port_sn","text":"<p>Description</p> <p>This command is used to set the source port of Socket. It is necessary to input 1 byte of Socket index value and 2 bytes of source port (low bytes in front). If two or more Sockets are in the same mode, the source port numbers must not be the same. For example, Socket 0 is in UDP mode, the source port number is 600, and Socket 1 is also in UDP mode. The source port number 600 cannot be used again, otherwise it may cause the0 opening failure.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : Low port</li> <li>X Register : High port</li> </ul> <p>Modify</p> <ul> <li>RES</li> </ul>"},{"location":"2024.2/assembly/#ch395_set_ttl","title":"ch395_set_ttl","text":"<p>Description</p> <p>This command is used to set Socket TTL. It is necessary to input 1 byte of Socket index value and 1 byte of TTL value. It shall be set after the Socket is opened, and the maximum value is 128</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>X Register : TTL value</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.2/assembly/#ch395_tcp_connect_sn","title":"ch395_tcp_connect_sn","text":"<p>Description</p> <p>Performs tcp connect</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.2/assembly/#ch395_tcp_disconnect_sn","title":"ch395_tcp_disconnect_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.2/assembly/#ch395_tcp_listen_sn","title":"ch395_tcp_listen_sn","text":"<p>Description</p> <p>This command is only valid in TCP mode, enabling the Socket to be in the monitoring mode, namely, TCP Server mode. It is necessary to input a 1 byte of Socket index value. This command must be executed after OPEN_SOCKET_SN. After sending this command, MCU shall send GET_CMD_STATUS to query the 0command execution status. In TCP Server mode, the Socket will always detect connection events, and the interrupt SINT_STAT_CONNECT will be generated until the connection is successful. Only one connection can be 0established for each Socket. If an eligible connection event is received again, Socket will send TCP RESET to the remote end tried to be connected.</p>"},{"location":"2024.2/assembly/#ch395_write_send_buf_sn","title":"ch395_write_send_buf_sn","text":"<p>Description</p> <p>This command is used to write data to Socket transmit buffer. It is necessary to input 1 byte of Socket index value, 2 bytes of length (low bytes in front) and several bytes of data stream. The length of input data must not be larger than the size of transmit buffer. However, in MACRAW mode, the maximum length of input data can only be 1514, and any redundant data will be discarded. After the external MCU writes the data, CH395 will encapsulate the data packet according to the working mode of Socket, and then send it. Before MCU receives SINT_STAT_SENBUF_FREE, it is not allowed to write data into Socket transmit buffer again</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>Y Register : Low length</li> <li>X Register : High length</li> <li>RESB : Adress ptr to read</li> </ul> <p>Modify</p> <ul> <li>RESTmp</li> </ul> <p>Example</p>"},{"location":"2024.2/c/","title":"C","text":""},{"location":"2024.2/c/#c","title":"C","text":""},{"location":"2024.2/c/#unsigned-char-ch395_check_exist","title":"unsigned char ch395_check_exist();","text":"<p>Description</p> <p>This command is used to test the communication interface and working state to check whether CH395 is working properly. This command needs to input 1 byte of data, which can be any data. If CH395 is working properly, the output data of CH395 will be the bitwise reverse of the input data. For example, if the input data is 57H, the output data will be A8H.</p>"},{"location":"2024.2/c/#void-ch395_clear_recv_buf_snunsigned-char-id_socket","title":"void ch395_clear_recv_buf_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>This command is used to clear the Socket receive buffer. It is necessary to input 1 byte of Socket index value. Upon receiving this command, CH395 will reset the receiving length of this Socket, and the receiving pointer will point to the buffer head.</p>"},{"location":"2024.2/c/#void-ch395_close_socket_snunsigned-char-socketid","title":"void ch395_close_socket_sn(unsigned char socketid)","text":"<p>Description</p> <p>This command is used to close Socket. It is necessary to input a 1 byte of Socket index value. After Socket is closed, the receive buffer and transmit buffer of Socket are emptied, but the configuration information is still reserved, and you just need to open the Socket again when using the Socket the next time. In TCP mode, CH395 will automatically disconnect TCP before turning off Socket.</p> <p>Input</p>"},{"location":"2024.2/c/#void-ch395_dhcp_enable","title":"void ch395_dhcp_enable()","text":"<p>Description</p> <p>This command is used to start or stop DHCP. It is necessary to input a 1-byte flag. If the flag is 1, it will indicate that DHCP is on; if the flag is 0, it will indicate that DHCP is off. CH395 must be initialized before DHCP is started. After DHCP is started, CH395 will broadcast DHCPDISCOVER message to the network to discover DHCP Server, request the address and other configuration parameters after finding DHCP Server, and then generate GINT_STAT_DHCP interrupt. MCU can send GET_DHCP_STATUS command to get DHCP status. If the status code is 0, it will indicate success, and MCU can send the command GET_IP_INF to get IP, MASK and other information. If the status code is 1, it will indicate error, which is generally caused by timeout, for example, no DHCP Server is found. DHCP is always in a working state after startup unless it receives a DHCP shutdown command from MCU. During this process, if DHCP Server reassigns a configuration to CH395 and the configuration is different from the original configuration, CH395 will still generate an interrupt. After timeout interrupt is generated, if DHCP Server is not found, CH395 will continue to send DHCPDISCOVER message at an interval of about 16 seconds. It takes about 20MS to execute this command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status</p> <p>Description</p> <p>Get cmd status</p>"},{"location":"2024.2/c/#unsigned-char-ch395_get_cmd_status","title":"unsigned char ch395_get_cmd_status();","text":""},{"location":"2024.2/c/#unsigned-char-ch395_get_dhcp_status","title":"unsigned char ch395_get_dhcp_status();","text":"<p>Description</p> <p>Get dhcp status</p>"},{"location":"2024.2/c/#unsigned-int-ch395_get_glob_int_status","title":"unsigned int ch395_get_glob_int_status();","text":"<p>Description</p> <p>Get General interrupt Status</p>"},{"location":"2024.2/c/#unsigned-char-ch395_get_ic_ver","title":"unsigned char ch395_get_ic_ver();","text":"<p>Description</p> <p>This command is used to get the chip and firmware versions. 1 byte of data returned is the version number, the bit 7 is 0, the bit 6 is 1, and the bits 5-0 are the version number. If the returned value is 41H, remove bits 7 and 6, and the version number will be 01H. It is called chip version in this text</p> <p>;;@inputA Socket id    ;;@modifyA    ;;@modifyX    ;;@returnsA Status of selected socket    ;;@<code>ca65    ;;@`  lda     #CH395_SOCKET1 ; Check socket 1    ;;@`  jsr     ch395_get_int_status_sn    ;;@`  ; Check interrupt type    ;;@`  and     #CH395_SINT_STAT_SEND_OK    ;;@`  cmp     #CH395_SINT_STAT_SEND_OK    ;;@`  beq     @send_ok    ;;@`  rts    ;;@</code> ldx     #CH395_GET_INT_STATUS_SN    stx     CH395_COMMAND_PORT    sta     CH395_DATA_PORT    lda     CH395_DATA_PORT    rts endproc</p>"},{"location":"2024.2/c/#unsigned-char-ch395_get_int_status_snunsigned-char-id_socket","title":"unsigned char ch395_get_int_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Check interrupt socket status</p> <p>Input</p>"},{"location":"2024.2/c/#void-ch395_get_ip_infunsigned-char-ip_infos","title":"void ch395_get_ip_inf(unsigned char ip_infos[]);","text":"<p>Description</p> <p>Get ip info : ip_infos must be 20 bytes length)</p>"},{"location":"2024.2/c/#void-ch395_get_mac_adressunsigned-char-macaddress","title":"void ch395_get_mac_adress(unsigned char macaddress[]);","text":"<p>Description</p> <p>Get mac address</p>"},{"location":"2024.2/c/#unsigned-char-ch395_get_phy_status","title":"unsigned char ch395_get_phy_status();","text":"<p>Description</p> <p>Get physical status</p>"},{"location":"2024.2/c/#void-ch395_get_recv_len_snunsigned-char-id_socket","title":"void ch395_get_recv_len_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p>"},{"location":"2024.2/c/#void-ch395_get_remot_ipp_snunsigned-char-ptr-unsigned-char-socket","title":"void ch395_get_remot_ipp_sn(unsigned char *ptr, unsigned char socket);","text":"<p>Description</p> <p>Get remote ip connected to the socket</p> <p>Input</p>"},{"location":"2024.2/c/#unsigned-int-ch395_get_socket_status_snunsigned-char-id_socket","title":"unsigned int ch395_get_socket_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Returns in A socket status (close/open ... )</p> <p>Input</p>"},{"location":"2024.2/c/#void-ch395_init","title":"void ch395_init();","text":"<p>Description</p> <p>;;@brief This command is used to initialize CH395, including initializing MAC, PHY and TCP/IP stack of CH395. Generally, it takes 350mS to execute the command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status.</p>"},{"location":"2024.2/c/#void-ch395_open_socket_snunsigned-char-id_socket","title":"void ch395_open_socket_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.2/c/#void-ch395_read_recv_buf_snunsigned-char-buffer-unsigned-int-ptr2unsigned-char-id_socket","title":"void ch395_read_recv_buf_sn(unsigned char *buffer, unsigned int ptr2,unsigned char ID_SOCKET);","text":"<p>Input</p>"},{"location":"2024.2/c/#void-ch395_reset_all","title":"void ch395_reset_all()","text":"<p>Description</p> <p>Reset ch395</p>"},{"location":"2024.2/c/#void-ch395_set_des_port_snunsigned-int-port-unsigned-char-id_socket","title":"void ch395_set_des_port_sn(unsigned int port, unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set dest port socket</p> <p>Input</p>"},{"location":"2024.2/c/#void-ch395_set_fun_paraunsigned-char-flag","title":"void ch395_set_fun_para(unsigned char flag)","text":"<p>Description</p> <p>Set fun para</p> <p>Description</p> <p>Set gateway ip addr</p> <p>Description</p> <p>This command is used to set the destination IP address of Socket. It is necessary to input 1 byte of Socket index value and 4 bytes of destination IP address. When Socket works in IPRAW, UDP, or TCP Client mode, 0the destination IP must be set before the command CMD_OPEN_SOCKET_SN is sent</p>"},{"location":"2024.2/c/#void-ch395_set_ip_addr_snunsigned-char-ip_addr-unsigned-char-id_socket","title":"void ch395_set_ip_addr_sn(unsigned char ip_addr[], unsigned char ID_SOCKET)","text":""},{"location":"2024.2/c/#void-ch395_set_ipraw_pro_snunsigned-char-id_socket","title":"void ch395_set_ipraw_pro_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p>"},{"location":"2024.2/c/#void-ch395_set_mac_adressunsigned-char-macaddress","title":"void ch395_set_mac_adress(unsigned char macaddress[]);","text":""},{"location":"2024.2/c/#void-ch395_set_proto_type_snunsigned-char-proto-unsigned-char-id_socket","title":"void ch395_set_proto_type_sn(unsigned char proto, unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.2/c/#void-ch395_set_retran_countunsigned-int-period","title":"void ch395_set_retran_count(unsigned int period);","text":"<p>Description</p> <p>Set retran period</p>"},{"location":"2024.2/c/#void-ch395_retran_periodunsigned-int-period","title":"void ch395_retran_period(unsigned int period);","text":"<p>Description</p> <p>Retran period</p>"},{"location":"2024.2/c/#void-ch395_set_sour_port_snunsigned-int-portunsigned-char-id_socket","title":"void ch395_set_sour_port_sn(unsigned int port,unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Set source socket</p> <p>Input</p> <p>Description</p> <p>This command is used to set Socket TTL. It is necessary to input 1 byte of Socket index value and 1 byte of TTL value. It shall be set after the Socket is opened, and the maximum value is 128</p>"},{"location":"2024.2/c/#ch395_set_ttlunsigned-char-id_socket-unsigned-char-ttl_value","title":"ch395_set_ttl(unsigned char ID_SOCKET, unsigned char ttl_value);","text":""},{"location":"2024.2/c/#void-ch395_tcp_connect_snunsigned-char-id_socket","title":"void ch395_tcp_connect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.2/c/#void-ch395_tcp_disconnect_snunsigned-char-id_socket","title":"void ch395_tcp_disconnect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.2/c/#void-ch395_tcp_listen_snunsigned-char-id_socket","title":"void ch395_tcp_listen_sn(unsigned char ID_SOCKET)","text":""},{"location":"2024.2/c/#void-ch395_write_send_buf_snunsigned-char-buffer-unsigned-int-lengthunsigned-char-id_socket","title":"void ch395_write_send_buf_sn(unsigned char *buffer, unsigned int length,unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Send data to socketid [Not working]</p> <p>Input</p>"},{"location":"2024.4/assembly/","title":"Assembly","text":""},{"location":"2024.4/assembly/#assembly","title":"Assembly","text":""},{"location":"2024.4/assembly/#ch395_check_exist","title":"ch395_check_exist","text":"<p>Description</p> <p>This command is used to test the communication interface and working state to check whether CH395 is working properly. This command needs to input 1 byte of data, which can be any data. If CH395 is working properly, the output data of CH395 will be the bitwise reverse of the input data. For example, if the input data is 57H, the output data will be A8H.</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Returns '#CH395_DETECTED' if it exists</li> </ul> <p>Example</p> <pre><code> jsr ch395_check_exist\n cmp #CH395_DETECTED\n beq ch395_connected\n rts\nch395_connected:\n</code></pre>"},{"location":"2024.4/assembly/#ch395_clear_recv_buf_sn","title":"ch395_clear_recv_buf_sn","text":"<p>Description</p> <p>This command is used to clear the Socket receive buffer. It is necessary to input 1 byte of Socket index value. Upon receiving this command, CH395 will reset the receiving length of this Socket, and the receiving pointer will point to the buffer head.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Socket ID\n jsr ch395_clear_recv_buf_sn\n</code></pre>"},{"location":"2024.4/assembly/#ch395_close_socket_sn","title":"ch395_close_socket_sn","text":"<p>Description</p> <p>This command is used to close Socket. It is necessary to input a 1 byte of Socket index value. After Socket is closed, the receive buffer and transmit buffer of Socket are emptied, but the configuration information is still reserved, and you just need to open the Socket again when using the Socket the next time. In TCP mode, CH395 will automatically disconnect TCP before turning off Socket.</p> <p>Input</p> <ul> <li>Accumulator : The id of the socket to close</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket ID\n jsr ch395_close_socket_sn\n</code></pre>"},{"location":"2024.4/assembly/#ch395_dhcp_enable","title":"ch395_dhcp_enable","text":"<p>Description</p> <p>This command is used to start or stop DHCP. It is necessary to input a 1-byte flag. If the flag is 1, it will indicate that DHCP is on; if the flag is 0, it will indicate that DHCP is off. CH395 must be initialized before DHCP is started. After DHCP is started, CH395 will broadcast DHCPDISCOVER message to the network to discover DHCP Server, request the address and other configuration parameters after finding DHCP Server, and then generate GINT_STAT_DHCP interrupt. MCU can send GET_DHCP_STATUS command to get DHCP status. If the status code is 0, it will indicate success, and MCU can send the command GET_IP_INF to get IP, MASK and other information. If the status code is 1, it will indicate error, which is generally caused by timeout, for example, no DHCP Server is found. DHCP is always in a working state after startup unless it receives a DHCP shutdown command from MCU. During this process, if DHCP Server reassigns a configuration to CH395 and the configuration is different from the original configuration, CH395 will still generate an interrupt. After timeout interrupt is generated, if DHCP Server is not found, CH395 will continue to send DHCPDISCOVER message at an interval of about 16 seconds. It takes about 20MS to execute this command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status</p> <p>Input</p> <ul> <li>Accumulator : The mode to activate DHCP mode</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"2024.4/assembly/#ch395_enter_sleep","title":"ch395_enter_sleep","text":"<p>Description</p> <p>This command enables CH395 chip in a low-power sleep suspended state. When MCU writes a new command to CH395 (no data input command, such as CMD_GET_IC_VER), it will exit the low-power state. For the parallel port and SPI interface communication modes, active SCS chip selection will also cause CH395 to exit the low-power state, so MCU shall immediately disable the SCS chip selection after sending the command CMD_ENTER_SLEEP. In sleep state, MAC and PHY of CH395 will be in power off mode and disconnect Ethernet. Typically, it takes several milliseconds for CH395 to exit the low-power state.</p> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_get_cmd_status","title":"ch395_get_cmd_status","text":"<p>Description</p> <p>This command is used to get the command execution status. CH395 will output 1 byte of data, which is the command execution state. The command execution status is as follows:</p> <p>Example</p> <pre><code> jsr ch395_get_cmd_status\n ; Check A for STATUS\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.4/assembly/#ch395_get_dhcp_status","title":"ch395_get_dhcp_status","text":"<p>Description</p> <p>Get dhcp status</p> <p>Example</p> <pre><code> jsr ch395_get_dhcp_status\n ; Check A for dhcp status\n rts\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> </ul>"},{"location":"2024.4/assembly/#ch395_get_glob_int_status_all","title":"ch395_get_glob_int_status_all","text":"<p>Description</p> <p>This command is used to get the global interrupt status. CH395 will output 2 bytes of global interrupt status after receiving this command. Global interrupt status is defined as follows:</p> <p>Returns</p> <ul> <li>Accumulator : int status state CH395_GINT_STAT_SOCK0 CH395_GINT_STAT_SOCK1 CH395_GINT_STAT_SOCK2 CH395_GINT_STAT_SOCK3 CH395_GINT_STAT_DHCP CH395_GINT_STAT_PHY_CHANGE CH395_GINT_STAT_IP_CONFLI CH395_GINT_STAT_UNREACH</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li> <p>X Register : int status state CH395_GINT_STAT_SOCK4 CH395_GINT_STAT_SOCK5 CH395_GINT_STAT_SOCK6 CH395_GINT_STAT_SOCK7</p> </li> <li> <p>X Register </p> </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status_all\n ; check accumulator to get interrupts states\n ; check X to get interrupts states\n</code></pre> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_get_glob_int_status","title":"ch395_get_glob_int_status","text":"<p>Description</p> <p>This command is used to get the global interrupt status. CH395 will output 1 byte of global interrupt status after receiving this command. Global interrupt status is defined as follows:</p> <p>Returns</p> <ul> <li>Accumulator : int status state CH395_GINT_STAT_SOCK0 CH395_GINT_STAT_SOCK1 CH395_GINT_STAT_SOCK2 CH395_GINT_STAT_SOCK3 CH395_GINT_STAT_DHCP CH395_GINT_STAT_PHY_CHANGE CH395_GINT_STAT_IP_CONFLI CH395_GINT_STAT_UNREACH</li> </ul> <p>Modify</p> <ul> <li>Accumulator  Bit Name Description</li> </ul> <p>7 GINT_STAT_SOCK3 Socket3 interrupt</p> <p>6 GINT_STAT_SOCK2 Socket2 interrupt</p> <p>5 GINT_STAT_SOCK1 Socket1 interrupt</p> <p>4 GINT_STAT_SOCK0 Socket0 interrupt</p> <p>3 GINT_STAT_DHCP DHCP interrupt</p> <p>2 GINT_STAT_PHY_CHANGE PHY status change interrupt</p> <p>1 GINT_STAT_IP_CONFLI IP conflict</p> <p>0 GINT_STAT_UNREACH Inaccessible interrupt</p> <p>\u2460 GINT_STAT_UNREACH: Inaccessible interrupt. When CH395 receives ICMP inaccessible interrupt</p> <p>message, it saves the IP address, port and protocol type of the inaccessible IP packet in the inaccessible</p> <p>information table, and then generates an interrupt. When the MCU receives the interrupt, it can send the</p> <p>command GET_UNREACH_IPPORT to get the inaccessible information.</p> <p>\u2461 GINT_STAT_IP_CONFLI: IP conflict interrupt. This interrupt is generated when CH395 detects that its</p> <p>IP address is the same as that of other network devices in the same network segment.</p> <p>\u2462 GINT_STAT_PHY_CHANGE: PHY change interrupt. This interrupt is generated when PHY connection</p> <p>of CH395 changes, for example, PHY state changes from the connected state to the disconnected state or</p> <p>from the disconnected state to the connected state. MCU can send GET_PHY_STATUS command to get</p> <p>the current PHY connection status.</p> <p>\u2463 GINT_STAT_DHCP: DHCP interrupt. If MCU enables DHCP function of CH395, CH395 will generate</p> <p>this interrupt. MCU can send the command CMD_GET_DHCP_STATUS to get the DHCP status. If the</p> <p>status is 0, it will indicate success; otherwise, it will indicate timeout failure.</p> <p>\u2464 GINT_STAT_SOCK0 - GINT_STAT_SOCK3: Socket interrupt. When there is an interrupt event in</p> <p>Socket, CH395 will generate this interrupt. MCU needs to send GET_INT_STATUS_SN to get the</p> <p>interrupt status of Socket. Please refer to GET_INT_STATUS_SN.</p> <p>When this command is completed, CH395 will set INT# pin to high level and clear the global interrupt</p> <p>status</p> <ul> <li>Accumulator </li> <li>Accumulator : Status </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_glob_int_status\n ; check accumulator to get interrupts states\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_ic_ver","title":"ch395_get_ic_ver","text":"<p>Description</p> <p>This command is used to get the chip and firmware versions. 1 byte of data returned is the version number, the bit 7 is 0, the bit 6 is 1, and the bits 5-0 are the version number. If the returned value is 41H, remove bits 7 and 6, and the version number will be 01H. It is called chip version in this text</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Version </li> </ul> <p>Example</p> <pre><code> jsr ch395_get_ic_ver\n ; Check A for version\n rts\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_int_status_sn","title":"ch395_get_int_status_sn","text":"<p>Description</p> <p>This command is used to get the interrupt status of Socket. It is necessary to input 1 byte of Socket index value. After receiving this command, CH395 will output 1 byte of Socket interrupt code. The interrupt code bits are defined as follows:</p> <p>A7 - Reserved</p> <p>6 SINT_STAT_TIM_OUT Timeout</p> <p>5 - Reserved</p> <p>4 SINT_STAT_DISCONNECT TCP disconnected</p> <p>3 SINT_STAT_CONNECT TCP connected</p> <p>2 SINT_STAT_RECV Receive buffer not empty</p> <p>1 SINT_STAT_SEND_OK Send Success</p> <p>0 SINT_STAT_SENBUF_FREE Transmit buffer free</p> <p>\u2460 SINT_STAT_SENBUF_FREE, transmit buffer free interrupt. After MCU writes data to the transmit</p> <p>buffer of Socket, CH395 will quickly copy the data to the internal protocol stack or MAC buffer, in order</p> <p>to encapsulate the data. When the data copying is finished, this interrupt will be generated. MCU can</p> <p>continue to write the subsequent data to the transmit buffer. After MCU writes data to the transmit buffer</p> <p>of Socket once, it must write the next data until the interruption is generated.</p> <p>\u2461 SINT_STAT_SEND_OK, send OK interrupt. This interrupt indicates that the data packet is sent</p> <p>successfully. This interrupt will be generated after Sokcet sends a packet of data successfully. After MCU</p> <p>writes data to Socket buffer once, CH395 may encapsulate the data into several data packets for sending,</p> <p>so several send OK interrupts may be generated.</p> <p>\u2462 SINT_STAT_CONNECT, TCP linkage interrupt, active only in TCP mode. It indicates that TCP</p> <p>connection is successful, and MCU can transmit data only after the interrupt is generated.</p> <p>\u2463 SINT_STAT_DISCONNECT, TCP disconnection interrupt, only active in TCP mode, indicating TCP</p> <p>disconnection.</p> <p>\u2464 SINT_STAT_TIM_OUT. This interrupt will be generated in TCP mode when a timeout occurs during a</p> <p>TCP connection, disconnection, data sending and other processes. This interrupt will be generated if the</p> <p>data is not sent successfully in IPRAW or UDP mode.</p> <p>After the interrupts SINT_STAT_DISCONNECT and SINT_STAT_TIM_OUT are generated, CH395 takes</p> <p>different actions depending on whether the FUN_PARA_FLAG_SOCKET_CLOSE bit is 1 or 0. If</p> <p>FUN_PARA_FLAG_SOCKET_CLOSE is 0, CH395 will actively set the Socket state to the OFF state and</p> <p>clear all relevant buffers after the above two interrupts are generated. Otherwise, it will not do any operation</p> <p>command to close the Socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li>Accumulator : Status of selected socket</li> </ul> <p>Example</p> <pre><code> lda #CH395_SOCKET1 ; Check socket 1\n jsr ch395_get_int_status_sn\n ; Check interrupt type\n and #CH395_SINT_STAT_SEND_OK\n cmp #CH395_SINT_STAT_SEND_OK\n beq @send_ok\n rts\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_ip_inf","title":"ch395_get_ip_inf","text":"<p>Description</p> <p>Get ip info</p> <p>Input</p> <ul> <li>Accumulator : the ptr to modify (Ptr must be 20 bytes length)</li> <li>X Register : the ptr to modify (Ptr must be 20 bytes length)</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RESTmp value</li> </ul> <p>Example</p> <pre><code> lda #&lt;ip_address\n ldx #&gt;ip_address\n ldx #$00\n jsr ch395_get_ip_inf\n rts\nip_address:\n .res 4\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_mac_adress","title":"ch395_get_mac_adress","text":"<p>Description</p> <p>Get mac address</p> <p>Input</p> <ul> <li>Accumulator : the ptr</li> <li>X Register : the ptr</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RESTmp value</li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : the content of ptr modified</p> </li> <li> <p>X Register : the content of ptr modified</p> </li> </ul> <p>Example</p> <pre><code> lda #&lt;mac_address\n ldx #&gt;mac_address\n ldx #$00\n jsr ch395_get_mac_adress\n rts\nmac_address:\n .res 10\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_phy_status","title":"ch395_get_phy_status","text":"<p>Description</p> <p>This command is used to get PHY connection status. After receiving this command, CH395 will query the current PHY connection status and output 1-byte PHY connection status code: PHY is disconnected when the connection status code is 01H; PHY connection is 10M full duplex when the connection status code is 02H; PHY connection is 10M half duplex when the connection status code is 04H. PHY connection is 100M full duplex when the connection status code is 08H; PHY connection is 100M half duplex when the connection status code is 10H</p> <p>Modify</p> <ul> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li>Accumulator : The physical status</li> </ul> <p>Example</p> <pre><code> jsr ch395_get_phy_status\n ; Check A physical status\n rts\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_recv_len_sn","title":"ch395_get_recv_len_sn","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_recv_len_sn\n ; check A and X for length received\nch395_connected:\n</code></pre> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The length</p> </li> <li> <p>X Register : The length</p> </li> </ul>"},{"location":"2024.4/assembly/#ch395_get_remot_ipp_sn","title":"ch395_get_remot_ipp_sn","text":"<p>Description</p> <p>This command is used to get the remote IP address and port number. It is necessary to input 1 byte of Socket index value. CH395 will output 4 bytes of IP address and 2 bytes of port number (low bytes in front). After Socket works in TCP Server mode and the connection is established, MCU can get the remote IP address and port number through this command</p> <p>Input</p> <ul> <li>Accumulator : The Socket for the ip to get</li> <li>X Register : The ptr (high) to store the ip</li> <li>Y Register : The ptr (low) to store the ip</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>X Register </li> <li>Y Register </li> <li>RES</li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n ldx #&lt;ip_dest\n ldy #&gt;ip_dest\n jsr ch395_get_remot_ipp_sn\n rts\nipdest:\n .byte 192,168,0,1\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_socket_status_sn","title":"ch395_get_socket_status_sn","text":"<p>Description</p> <p>This command is used to get Socket status. It is necessary to input a 1 byte of Socket index value. CH395 will output a 2-byte status code when receiving this command. The first status code is the status code of Socket. The status code of Socket is defined as follows:</p> <p>00H SOCKET_CLOSED</p> <p>05H SOCKET_OPEN</p> <p>The second status code is TCP status code, which is only meaningful when TCP mode has been on. TCP</p> <p>status code is defined as follows:</p> <p>Code Name Description</p> <p>00H TCP_CLOSED Closed</p> <p>01H TCP_LISTEN Monitoring</p> <p>02H TCP_SYN_SENT SYN sent</p> <p>03H TCP_SYN_RCVD SYN received</p> <p>04H TCP_ESTABLISHED TCP connection established</p> <p>05H TCP_FIN_WAIT_1 The active closing side first sends FIN</p> <p>06H TCP_FIN_WAIT_2 The active closing side receives an ACK from FIN</p> <p>07H TCP_CLOSE_WAIT The passive closing side receives FIN</p> <p>08H TCP_CLOSING Closing</p> <p>09H TCP_LAST_ACK The passive closing side sends FIN</p> <p>0AH TCP_TIME_WAIT 2MLS waiting status</p> <p>TCP status is defined in TCP/IP protocol. Please refer to TCP/IP protocol for the detailed meaning</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>X Register </li> <li>Accumulator </li> </ul> <p>Returns</p> <ul> <li> <p>Accumulator : The status</p> </li> <li> <p>X Register : The state</p> </li> </ul> <p>Example</p> <pre><code> lda #$01 ; Socket 1\n jsr ch395_get_socket_status_sn\n ; check A and X for the state\n cmp #CH395_SOCKET_CLOSED\n beq @soclet is closed\n</code></pre>"},{"location":"2024.4/assembly/#ch395_get_unreach_ipport","title":"ch395_get_unreach_ipport","text":"<p>Description</p> <p>This command is used to get an inaccessible IP, ports and protocol type. CH395 will generate an inaccessible interrupt when an inaccessible message is received. MCU can use this command to get inaccessible information. After receiving this command, CH395 will output 1 byte of inaccessible code, 1 byte of protocol type, 2 bytes of port number (low bytes in front), and 4 bytes of IP in turn. MCU can judge whether the protocol, port or IP is inaccessible according to the inaccessible codes. For inaccessible codes, refer to RFC792 (CH395INC.H defines four common inaccessible codes).</p> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_init","title":"ch395_init","text":"<p>Description</p> <p>This command is used to initialize CH395, including initializing MAC, PHY and TCP/IP stack of CH395. Generally, it takes 350mS to execute the command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status.</p> <p>Modify</p> <ul> <li>Accumulator  Description</li> </ul> <p>Reset ch395</p> <p>Example</p> <pre><code> jsr ch395_init\n ; Wait a bit\n</code></pre>"},{"location":"2024.4/assembly/#ch395_open_socket_sn","title":"ch395_open_socket_sn","text":"<p>Description</p> <p>This command is used to open Socket and use the necessary steps of Socket. It is necessary to input 1 byte of Socket index value. After sending this command, MCU shall send GET_CMD_STATUS to query the command execution status. After opening Socket in UDP, IPRAW or MACRAW mode and returning successfully, data transmission can be performed. Before this command is sent, necessary settings must be made for destination IP, protocol type, source port, destination port, etc. Please refer to 8.3 Application Reference Steps for detailed steps.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.4/assembly/#ch395_read_recv_buf_sn","title":"ch395_read_recv_buf_sn","text":"<p>Description</p> <p>This command is used to read data from Socket receive buffer. It is necessary to input 1 byte of Socket index value and 2 bytes of length (low bytes in front). CH395 will output several bytes of data stream based on the length value. In actual application, the command RECV_LEN_SN can be firstly sent to get the actual effective length of the current buffer. The length of the read data can be less than the actual effective length of the buffer, the unread data is still reserved in the receive buffer, and MCU can continue to read through this command. In MACRAW mode, the processing modes are different. In MACRAW mode, the receive buffer is a frame buffer, which can cache only 1 frame of Ethernet data. After CH395 processes the command READ_RECV_BUF_SN, Socket0 receive buffer will be cleared, so MCU shall read all valid data of the buffer at a time.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : Length low</li> <li>X Register : length high</li> <li>RES : ptr to fill</li> </ul> <p>Modify</p> <ul> <li>RESBtmp value</li> </ul>"},{"location":"2024.4/assembly/#ch395_reset_all","title":"ch395_reset_all","text":"<p>Description</p> <p>This command enables CH395 to perform a hardware reset. Typically, hardware reset is completed within 50mS.</p> <p>Example</p> <pre><code> jsr ch395_reset_all\n ; Wait a bit\n</code></pre>"},{"location":"2024.4/assembly/#ch395_set_baudrate","title":"ch395_set_baudrate","text":"<p>Description</p> <p>This command is used to set the baud rate of CH395 for serial communication. When CH395 works in serial communication mode, the default communication baud rate is set by the level combination of SDO, SDI and SCK pins (refer to Section 6.4 of this datasheet) after reset. When these pins are suspended, the baud rate is 9600bps by default. If MCU supports high communication speed, the serial communication baud rate can be dynamically regulated through this command. This command requires the input of three data, namely, baudrate coefficient 0, baud rate coefficient 1 and baud rate coefficient 2. The following table shows the corresponding relationship with baud rates.</p>"},{"location":"2024.4/assembly/#ch395_set_des_port_sn","title":"ch395_set_des_port_sn","text":"<p>Description</p> <p>This command is used to set the Socket destination port. It is necessary to input 1 byte of Socket index value and 2 bytes of destination port (the low bytes are in front). When Socket works in UDP or TCP Client mode, this value must be set.</p> <p>Input</p> <ul> <li>Accumulator : Socketid </li> <li>Y Register : Low int</li> <li>X Register : high int</li> </ul> <p>Modify</p> <ul> <li>REStmp</li> </ul> <p>Example</p> <pre><code> lda #$01\n ldy #80\n ldx #$00\n jsr ch395_set_des_port_sn\n rts\n</code></pre>"},{"location":"2024.4/assembly/#ch395_set_fun_para","title":"ch395_set_fun_para","text":"<p>Description</p> <p>Set fun para</p> <p>Input</p> <ul> <li>Accumulator : Value </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> <li>Accumulator </li> </ul>"},{"location":"2024.4/assembly/#ch395_set_gwip_addr","title":"ch395_set_gwip_addr","text":"<p>Description</p> <p>This command is used to set the gateway address for CH395. It is necessary to input 4 bytes of IP address</p> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_set_ip_addr","title":"ch395_set_ip_addr","text":"<p>Description</p> <p>This command is used to set IP address for CH395. It is necessary to input 4 bytes of IP address, with low bytes of IP in front. For all commands including IP input or output in this datasheet, IP low bytes are in front. This will not be explained below</p> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_set_ip_addr_sn","title":"ch395_set_ip_addr_sn","text":"<p>Description</p> <p>This command is used to set the destination IP address of Socket. It is necessary to input 1 byte of Socket index value and 4 bytes of destination IP address. When Socket works in IPRAW, UDP, or TCP Client mode, 0the destination IP must be set before the command CMD_OPEN_SOCKET_SN is sent</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : low ptr ip</li> <li>X Register : high ptr ip</li> </ul> <p>Modify</p> <ul> <li>REStmp</li> </ul>"},{"location":"2024.4/assembly/#ch395_set_ipraw_pro_sn","title":"ch395_set_ipraw_pro_sn","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>X Register : the mode proto</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.4/assembly/#ch395_set_mac_adress","title":"ch395_set_mac_adress","text":"<p>Description</p> <p>This command is used to set MAC address for CH395. It is necessary to input 6 bytes of MAC, with low bytes of MAC address in front. CH395 chip will store MAC address in the internal EEPROM. It will take 100mS to execute this command.MAC address assigned by IEEE has been burned when CH395 chip is delivered. If it is not necessary, please do not set MAC address</p> <p>Input</p> <ul> <li>Accumulator : Low ptr mac adress</li> <li>X Register : High ptr mac adress</li> </ul> <p>Modify</p> <ul> <li>Accumulator </li> <li>Y Register </li> <li>RESTmp</li> </ul>"},{"location":"2024.4/assembly/#ch395_set_mac_filt","title":"ch395_set_mac_filt","text":"<p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_set_mask_addr","title":"ch395_set_mask_addr","text":"<p>Description</p> <p>This command is used to set the subnet mask for CH395. It is necessary to input 4 bytes of mask for this command. It is 255.255.255.0 by default and may not be set</p> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_set_phy","title":"ch395_set_phy","text":"<p>Description</p> <p>This command is used to set Ethernet PHY connection mode of CH395. The connection mode is automated negotiation mode by default. This command needs to input 1 byte of data, which is the connection mode code: Disconnect PHY when the connection mode code is 01H; PHY is 10M full duplex when the connection mode code is 02H; PHY is 10M half duplex when the connection mode code is 04H; PHY is 100M full duplex when the connection mode code is 08H; PHY is 100M half duplex when the connection mode code is 10H; PHY is automated negotiation when the connection mode code is 20H. When CH395 receives this command, it will reset MAC and PHY and reconnect according to the newly set connection mode. If Ethernet is already connected, it will be disconnected and reconnected.</p> <p>Does not work</p>"},{"location":"2024.4/assembly/#ch395_set_proto_type_sn","title":"ch395_set_proto_type_sn","text":"<p>Description</p> <p>This command is used to set the working mode of Socket. It is necessary to input 1 byte of Socket index value and 1 byte of working mode. The working mode is defined as follows:</p> <p>Code Name Description</p> <p>03H PROTO_TYPE_TCP TCP mode</p> <p>02H PROTO_TYPE_UDP UDP mode</p> <p>01H PROTO_TYPE_MAC_RAW MAC original message mode</p> <p>00H PROTO_TYPE_IP_RAW IP original message mode</p> <p>This command must be executed before CMD_OPEN_SOCKET_SN. Refer to 8.3 Application Reference</p> <p>Steps for detailed steps.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>X Register : Proto mode</li> </ul> <p>Modify</p> <ul> <li>Y Register tmp</li> </ul> <p>Example</p> <pre><code> lda #$00 ; Socket\n ldx #CH395_PROTO_TYPE_TCP\n jsr ch395_set_proto_type_sn\n</code></pre>"},{"location":"2024.4/assembly/#ch395_set_retran_count","title":"ch395_set_retran_count","text":"<p>Description</p> <p>This command is used to set the number of retries. It is necessary to input 1 byte of number of retries. The allowable maximum value is 20. If the input data is more than 20, it will be processed as 20. The default number of retries is 12, and retries are only valid in TCP mode.</p> <p>Input</p> <ul> <li>Accumulator : Retran period</li> </ul> <p>Modify</p> <ul> <li>X Register </li> </ul>"},{"location":"2024.4/assembly/#ch395_set_retran_period","title":"ch395_set_retran_period","text":"<p>Description</p> <p>This command is used to set the retry cycle. It is necessary to input 2 bytes of number of cycles of (with low bytes in front) in milliseconds. The allowable maximum value is 1000. The total retry time is N * M, N is the number of retries, and M is the retry cycle. The default retry cycle is 500MS and retries are only valid in TCP mode.</p> <p>Input</p> <ul> <li>Accumulator : Period </li> <li>X Register : Period </li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul> <p>Example</p> <pre><code> lda #$FF\n ldx #$FF\n jsr ch395_retran_period\n rts\n</code></pre>"},{"location":"2024.4/assembly/#ch395_set_sour_port_sn","title":"ch395_set_sour_port_sn","text":"<p>Description</p> <p>This command is used to set the source port of Socket. It is necessary to input 1 byte of Socket index value and 2 bytes of source port (low bytes in front). If two or more Sockets are in the same mode, the source port numbers must not be the same. For example, Socket 0 is in UDP mode, the source port number is 600, and Socket 1 is also in UDP mode. The source port number 600 cannot be used again, otherwise it may cause the0 opening failure.</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> <li>Y Register : Low port</li> <li>X Register : High port</li> </ul> <p>Modify</p> <ul> <li>RES</li> </ul>"},{"location":"2024.4/assembly/#ch395_set_ttl","title":"ch395_set_ttl","text":"<p>Description</p> <p>This command is used to set Socket TTL. It is necessary to input 1 byte of Socket index value and 1 byte of TTL value. It shall be set after the Socket is opened, and the maximum value is 128</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>X Register : TTL value</li> </ul> <p>Modify</p> <ul> <li>Y Register </li> </ul>"},{"location":"2024.4/assembly/#ch395_tcp_connect_sn","title":"ch395_tcp_connect_sn","text":"<p>Description</p> <p>Performs tcp connect</p> <p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.4/assembly/#ch395_tcp_disconnect_sn","title":"ch395_tcp_disconnect_sn","text":"<p>Input</p> <ul> <li>Accumulator : Socket id</li> </ul>"},{"location":"2024.4/assembly/#ch395_tcp_listen_sn","title":"ch395_tcp_listen_sn","text":"<p>Description</p> <p>This command is only valid in TCP mode, enabling the Socket to be in the monitoring mode, namely, TCP Server mode. It is necessary to input a 1 byte of Socket index value. This command must be executed after OPEN_SOCKET_SN. After sending this command, MCU shall send GET_CMD_STATUS to query the 0command execution status. In TCP Server mode, the Socket will always detect connection events, and the interrupt SINT_STAT_CONNECT will be generated until the connection is successful. Only one connection can be 0established for each Socket. If an eligible connection event is received again, Socket will send TCP RESET to the remote end tried to be connected.</p>"},{"location":"2024.4/assembly/#ch395_write_send_buf_sn","title":"ch395_write_send_buf_sn","text":"<p>Description</p> <p>This command is used to write data to Socket transmit buffer. It is necessary to input 1 byte of Socket index value, 2 bytes of length (low bytes in front) and several bytes of data stream. The length of input data must not be larger than the size of transmit buffer. However, in MACRAW mode, the maximum length of input data can only be 1514, and any redundant data will be discarded. After the external MCU writes the data, CH395 will encapsulate the data packet according to the working mode of Socket, and then send it. Before MCU receives SINT_STAT_SENBUF_FREE, it is not allowed to write data into Socket transmit buffer again</p> <p>Input</p> <ul> <li>Accumulator : Socket ID</li> <li>Y Register : Low length</li> <li>X Register : High length</li> <li>RESB : Adress ptr to read</li> </ul> <p>Modify</p> <ul> <li>RESTmp</li> </ul> <p>Example</p>"},{"location":"2024.4/c/","title":"C","text":""},{"location":"2024.4/c/#c","title":"C","text":""},{"location":"2024.4/c/#unsigned-char-ch395_check_exist","title":"unsigned char ch395_check_exist();","text":"<p>Description</p> <p>This command is used to test the communication interface and working state to check whether CH395 is working properly. This command needs to input 1 byte of data, which can be any data. If CH395 is working properly, the output data of CH395 will be the bitwise reverse of the input data. For example, if the input data is 57H, the output data will be A8H.</p>"},{"location":"2024.4/c/#void-ch395_clear_recv_buf_snunsigned-char-id_socket","title":"void ch395_clear_recv_buf_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>This command is used to clear the Socket receive buffer. It is necessary to input 1 byte of Socket index value. Upon receiving this command, CH395 will reset the receiving length of this Socket, and the receiving pointer will point to the buffer head.</p>"},{"location":"2024.4/c/#void-ch395_close_socket_snunsigned-char-socketid","title":"void ch395_close_socket_sn(unsigned char socketid)","text":"<p>Description</p> <p>This command is used to close Socket. It is necessary to input a 1 byte of Socket index value. After Socket is closed, the receive buffer and transmit buffer of Socket are emptied, but the configuration information is still reserved, and you just need to open the Socket again when using the Socket the next time. In TCP mode, CH395 will automatically disconnect TCP before turning off Socket.</p> <p>Input</p>"},{"location":"2024.4/c/#void-ch395_dhcp_enable","title":"void ch395_dhcp_enable()","text":"<p>Description</p> <p>This command is used to start or stop DHCP. It is necessary to input a 1-byte flag. If the flag is 1, it will indicate that DHCP is on; if the flag is 0, it will indicate that DHCP is off. CH395 must be initialized before DHCP is started. After DHCP is started, CH395 will broadcast DHCPDISCOVER message to the network to discover DHCP Server, request the address and other configuration parameters after finding DHCP Server, and then generate GINT_STAT_DHCP interrupt. MCU can send GET_DHCP_STATUS command to get DHCP status. If the status code is 0, it will indicate success, and MCU can send the command GET_IP_INF to get IP, MASK and other information. If the status code is 1, it will indicate error, which is generally caused by timeout, for example, no DHCP Server is found. DHCP is always in a working state after startup unless it receives a DHCP shutdown command from MCU. During this process, if DHCP Server reassigns a configuration to CH395 and the configuration is different from the original configuration, CH395 will still generate an interrupt. After timeout interrupt is generated, if DHCP Server is not found, CH395 will continue to send DHCPDISCOVER message at an interval of about 16 seconds. It takes about 20MS to execute this command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status</p> <p>Description</p> <p>Get cmd status</p>"},{"location":"2024.4/c/#unsigned-char-ch395_get_cmd_status","title":"unsigned char ch395_get_cmd_status();","text":""},{"location":"2024.4/c/#unsigned-char-ch395_get_dhcp_status","title":"unsigned char ch395_get_dhcp_status();","text":"<p>Description</p> <p>Get dhcp status</p>"},{"location":"2024.4/c/#unsigned-int-ch395_get_glob_int_status","title":"unsigned int ch395_get_glob_int_status();","text":"<p>Description</p> <p>Get General interrupt Status</p>"},{"location":"2024.4/c/#unsigned-char-ch395_get_ic_ver","title":"unsigned char ch395_get_ic_ver();","text":"<p>Description</p> <p>This command is used to get the chip and firmware versions. 1 byte of data returned is the version number, the bit 7 is 0, the bit 6 is 1, and the bits 5-0 are the version number. If the returned value is 41H, remove bits 7 and 6, and the version number will be 01H. It is called chip version in this text</p>"},{"location":"2024.4/c/#unsigned-char-ch395_get_int_status_snunsigned-char-id_socket","title":"unsigned char ch395_get_int_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Check interrupt socket status</p> <p>Input</p> <p>;;@inputA Socket id    ;;@modifyA    ;;@modifyX    ;;@returnsA Status of selected socket    ;;@<code>ca65    ;;@`  lda     #CH395_SOCKET1 ; Check socket 1    ;;@`  jsr     ch395_get_int_status_sn    ;;@`  ; Check interrupt type    ;;@`  and     #CH395_SINT_STAT_SEND_OK    ;;@`  cmp     #CH395_SINT_STAT_SEND_OK    ;;@`  beq     @send_ok    ;;@`  rts    ;;@</code> ldx     #CH395_GET_INT_STATUS_SN    stx     CH395_COMMAND_PORT    sta     CH395_DATA_PORT    lda     CH395_DATA_PORT    rts endproc</p>"},{"location":"2024.4/c/#void-ch395_get_ip_infunsigned-char-ip_infos","title":"void ch395_get_ip_inf(unsigned char ip_infos[]);","text":"<p>Description</p> <p>Get ip info : ip_infos must be 20 bytes length)</p>"},{"location":"2024.4/c/#void-ch395_get_mac_adressunsigned-char-macaddress","title":"void ch395_get_mac_adress(unsigned char macaddress[]);","text":"<p>Description</p> <p>Get mac address</p>"},{"location":"2024.4/c/#unsigned-char-ch395_get_phy_status","title":"unsigned char ch395_get_phy_status();","text":"<p>Description</p> <p>Get physical status</p>"},{"location":"2024.4/c/#void-ch395_get_recv_len_snunsigned-char-id_socket","title":"void ch395_get_recv_len_sn(unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Get the length received from socket</p> <p>Input</p>"},{"location":"2024.4/c/#void-ch395_get_remot_ipp_snunsigned-char-ptr-unsigned-char-socket","title":"void ch395_get_remot_ipp_sn(unsigned char *ptr, unsigned char socket);","text":"<p>Description</p> <p>Get remote ip connected to the socket</p> <p>Input</p>"},{"location":"2024.4/c/#unsigned-int-ch395_get_socket_status_snunsigned-char-id_socket","title":"unsigned int ch395_get_socket_status_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Returns in A socket status (close/open ... )</p> <p>Input</p>"},{"location":"2024.4/c/#void-ch395_init","title":"void ch395_init();","text":"<p>Description</p> <p>;;@brief This command is used to initialize CH395, including initializing MAC, PHY and TCP/IP stack of CH395. Generally, it takes 350mS to execute the command. MCU can send GET_CMD_STATUS to query whether the execution has finished and the execution status.</p>"},{"location":"2024.4/c/#void-ch395_open_socket_snunsigned-char-id_socket","title":"void ch395_open_socket_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.4/c/#void-ch395_read_recv_buf_snunsigned-char-buffer-unsigned-int-ptr2unsigned-char-id_socket","title":"void ch395_read_recv_buf_sn(unsigned char *buffer, unsigned int ptr2,unsigned char ID_SOCKET);","text":"<p>Input</p>"},{"location":"2024.4/c/#void-ch395_reset_all","title":"void ch395_reset_all()","text":"<p>Description</p> <p>Reset ch395</p>"},{"location":"2024.4/c/#void-ch395_set_des_port_snunsigned-int-port-unsigned-char-id_socket","title":"void ch395_set_des_port_sn(unsigned int port, unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set dest port socket</p> <p>Input</p>"},{"location":"2024.4/c/#void-ch395_set_fun_paraunsigned-char-flag","title":"void ch395_set_fun_para(unsigned char flag)","text":"<p>Description</p> <p>Set fun para</p> <p>Description</p> <p>Set gateway ip addr</p> <p>Description</p> <p>This command is used to set the destination IP address of Socket. It is necessary to input 1 byte of Socket index value and 4 bytes of destination IP address. When Socket works in IPRAW, UDP, or TCP Client mode, 0the destination IP must be set before the command CMD_OPEN_SOCKET_SN is sent</p>"},{"location":"2024.4/c/#void-ch395_set_ip_addr_snunsigned-char-ip_addr-unsigned-char-id_socket","title":"void ch395_set_ip_addr_sn(unsigned char ip_addr[], unsigned char ID_SOCKET)","text":""},{"location":"2024.4/c/#void-ch395_set_ipraw_pro_snunsigned-char-id_socket","title":"void ch395_set_ipraw_pro_sn(unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Set ipraw protocol on socket</p> <p>Input</p>"},{"location":"2024.4/c/#void-ch395_set_mac_adressunsigned-char-macaddress","title":"void ch395_set_mac_adress(unsigned char macaddress[]);","text":""},{"location":"2024.4/c/#void-ch395_set_proto_type_snunsigned-char-proto-unsigned-char-id_socket","title":"void ch395_set_proto_type_sn(unsigned char proto, unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.4/c/#void-ch395_set_retran_countunsigned-int-period","title":"void ch395_set_retran_count(unsigned int period);","text":"<p>Description</p> <p>Set retran period</p>"},{"location":"2024.4/c/#void-ch395_retran_periodunsigned-int-period","title":"void ch395_retran_period(unsigned int period);","text":"<p>Description</p> <p>Retran period</p>"},{"location":"2024.4/c/#void-ch395_set_sour_port_snunsigned-int-portunsigned-char-id_socket","title":"void ch395_set_sour_port_sn(unsigned int port,unsigned char ID_SOCKET)","text":"<p>Description</p> <p>Set source socket</p> <p>Input</p> <p>Description</p> <p>This command is used to set Socket TTL. It is necessary to input 1 byte of Socket index value and 1 byte of TTL value. It shall be set after the Socket is opened, and the maximum value is 128</p>"},{"location":"2024.4/c/#ch395_set_ttlunsigned-char-id_socket-unsigned-char-ttl_value","title":"ch395_set_ttl(unsigned char ID_SOCKET, unsigned char ttl_value);","text":""},{"location":"2024.4/c/#void-ch395_tcp_connect_snunsigned-char-id_socket","title":"void ch395_tcp_connect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.4/c/#void-ch395_tcp_disconnect_snunsigned-char-id_socket","title":"void ch395_tcp_disconnect_sn(unsigned char ID_SOCKET)","text":"<p>Input</p>"},{"location":"2024.4/c/#void-ch395_tcp_listen_snunsigned-char-id_socket","title":"void ch395_tcp_listen_sn(unsigned char ID_SOCKET)","text":""},{"location":"2024.4/c/#void-ch395_write_send_buf_snunsigned-char-buffer-unsigned-int-lengthunsigned-char-id_socket","title":"void ch395_write_send_buf_sn(unsigned char *buffer, unsigned int length,unsigned char ID_SOCKET);","text":"<p>Description</p> <p>Send data to socketid [Not working]</p> <p>Input</p>"}]}